#include <iostream>

// Q. 전처리기 ?
// 전처리기 : 소스를 컴파일 하기에 앞서, 소스파일을 처리하는 컴파일러의 한 부분이다.

// Q. 스택 프레임 ?
// 메모리의 스택 영역은, 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다
// 스택 영역은, 함수의 호출과 함께 할당되며, 함수의 호출이 안료되면 소멸한다.

// 함수가 호출되면, 스택에는 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소값, 함수에서 선언된 지역 변수등이 저장된다.
// 스택 프레임이란, 스택 영역에 차례대로, 저장되는 함수의 호출 정보.를 의미한다.
// 이러한 스택 프레임 덕분에 함수의 호출이 모두 끝난 뒤, 해당 함수가 호출되기 이전 상태로 되돌아갈 수 있다. 

// Q. 일반함수와 비교한 매크고 함수의 장점 2개
// - 일반함수에 비해 실행 속도가 빠르고
// - 자료형에 따라서 별도로 함수를 정의하지 않아도 된다.

// 함수의 호출을 완성하기 위해서는, 별도의 스택 메모리 공간이 필요하고
// 호출된 함수로의 이동 및 반환의 과정을 거쳐야 한다.

// 더 구체적으로 보자면
// 1. 함수 호출 과정
// - 함수 호출 > 호출된 시점의 주소값 스택에 저장 > 함수 매개변수,지역 변수 스택에 저장 > 함수 호출
// 2. 함수 리턴 과정
// - 함수 종료 > 함수의 리턴값을 임시 저장소에 저장 > 스택에서 호출 시점의 주소값 꺼냄 > 호출된 시점으로 복귀 

int func(int a, int b) // 매개변수,지역 변수 스택에 저장 
{
    return a + b; // 리턴값을 임시 저장소에 저장 
};

int main()
{
    int num = func(5,1); // 함수 호출 --> 함수 호출 시점에 이곳의 주소값을 스택에 저장 
    return 0;
}

// 이러한 과정이 수없이 반복되면
// 처리시간, 메모리, cpu 자원이 불필요하게 쓰인다 
// 이러한 현상을 "오버헤드(overhead)" 현상. 이라고 한다 .

// 반면, 매크로 함수는 정의된 몸체로 치환이 이뤄지니 일반함수의 호출이 거치는 과정이 불필요하고
// 이로 인해 실행 속도가 빨라질 수 밖에 없다.

// 또한, 전달되는 인자의 자료형에 구분을 받지 않기 때문에, 자료형에 의존적이지 않다.

#define SUB(x) (x) * (x)

int func(int x)
{
    return x*x;
};

int main()
{
    int a = SUB(3);

    // 일반 함수
    int b = func(3);

    return 0;
}