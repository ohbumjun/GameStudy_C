// Q. 가상함수 테이블 특성 3개 ----

// - 한개 이상의 가상함수를 포함하는 클래스에 대해서는 컴파일러가 "가상함수 테이블"을 만든다.
// 이는 실제 호출되어야할 함수의 위치 정보를 담고 있는 테이블이다

// - 가상함수 테이블은 key - value 구조로 되어 있다
// key는 호출하고자 하는 함수를 구분 지어주는 구분자의 역할을 한다.
// value는 구분자에 해당하는 함수의 주소 정보를 알려주는 역할을 한다.

// - A 클래스를 B가 상속. B에서 특정 가상함수 func을 오버라이딩할 경우에 ,
// A 클래스의 오버라이딩 된 함수 func에 대한 정보가 기싱힘수 테이블에 존재하지 않는다.
// 따라서, 오버라이딩 된 가상함수를 호출하면, 무조건 가장 마지막에 오버라이딩한 유도 클래스의 
// 멤버함수가 호출된다.


// Q. 가상함수 테이블이 참조되는 방식 2 ----

// - 가상함수 테이블은 객체의 생성과 상관없이 메모리 공간에 할당된다
// - main 함수가 호출되기 이전에 가상함수 테이블이 메모리 공간에 할당된다.


// Q. 다중 상속의 문제점 --- //

// 두 기초 클래스에 동일한 이름의 멤버가 존재하는 경우에는 문제 발생
// 어떤 클래스에 선언된 멤버에 접근을 하려는 것인지 알 수 없기 때문이다.
// 따라서, 호출하려는 클래스 :: 멤버함수. 개념으로 함수호출을 진행해야 한다. (어느 클래스에 정의된 함수를 호출할 것인가)
 
class A 
{
public :
    void func(){} ///
};

class B
{
public :
    void func(){}
};

class C : public A, public B
{
public :
    void complexFunc()
    {
        func();
    } // A,B 중 어떤 클래스의 func 함수를 실행해야 하는가 
}

