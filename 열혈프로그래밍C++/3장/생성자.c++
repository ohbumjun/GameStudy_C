/* 생성자 특징  */

// 객체를 생성과 동시에 초기화 한다
// 객체 생성시 딱 한번 호출된다. 

/* 멤버 이니셜라이저 특징 3 */
// - 이니셜라이저를 이용하면
// 선언과 동시에 초기화가 이루어지는 형태로 바이너리 코드가 생성된다.

// - const 멤버 변수를 초기화 할 수 있다
// ( const 멤버 변수는 선언과 동시에 초기화가 일어나야 하기 때문이다)
// ( 반대로 말하면, 이니셜라이저를 통해서만 const 멤버변수가 초기화 된다.)

// - 참조자도 이니셜라이저를 통해서 초기화 될 수 있다.
// (참조자도 마찬가지로, 선언과 동시에 초기화 되어야 한다)

class Hi
{
private :
    const int num1;
public :
    Hi(int n1) : num1(n1){}
    /*
    num1(n1) ? --- 
    int num1;
    num1 = n1;

    선언과 초기화를 각각 별도의 문장에서 진행하는 형태로
    바이너리 코드가 생성된다. 
    //*/
};

// Q ---------------- 
class SimpleClass
{
public :
    SimpleClass(){}
};

int main()
{
    SimpleClass sc1(); // 이것이 생성자 호출을 하지 않는 이유 ?
    // SimpleClass sc1; // 생성자 호출 
}

// 이는 함수의 원형.에 해당한다.
// 즉, 컴파일러에게 이미 함수에 대한 정보를 알려주는 것
// 반환형, 함수 이름, 매개변수

// 보통, 함수 원형은 전역적으로 (함수 밖)에 선언하지만, 함수 안에서도 선언가능하다.


// Q. 객체의 생성과정 3가지 단계
// - 메모리 공간 할당
// - 이너셜라이저를 이용한 멤버변수 초기화
// - 생성자의 몸체부분 실행 


// Q. 객체 생성의 필수적 조건 한가지

// - 반드시 생성자 하나가 호출되어야 한다
// 이러한 조건에 예외를 두지 않기 위해서, 생성자를 정의하지 않은 클래스에서는
// 컴파일러에 의해, 디폴트 생성자라는 것이 자동으로 만들어진다
// 인자 없고, 내부적으로 아무것도 안하고 AA(){}

// Q. 아래가 컴파일 에러가 나는 이유
class AA
{
private :
	int num;
public :
	AA(int n) : num(n){};
};

int main()
{
	AA a;
	return 0;
}

// 디폴트 생성자는 생성자가 하나도 정의되어 있지 않을 때에 '만' 삽입된다.
// 위의 경우, AA a에서 교우하는 생성자가 정의되지도 않았고, 자동으로 생성되지도 않기 때문 

// Q. 생성자와 접근 제어 지시자, 이유
// - 기본 디폴트 : 생성자는 public으로 선언된다.
// - 보통 객체의 생성은 클래스의 외부에서 진행되기 때문이다. 

// Q. private 생성자를 통한 객체 생성 예시
class Simple
{
public :
    Simple(){}
    Simple& createObj()
    {
        Simple* ptr = new Simple;
        return *ptr;
    }
};

int main()
{
    Simple origin;
    // 참조형을 반환하는 함수는, 참조자로 받을 수 있다.
    // 참조자를 통해 힙에 할당된 메모리 공간을 참조할 수 있다 ! 
    Simple& obj = origin.createObj(); 
    return 0;
}

// Q. malloc 함수가 생성자를 호출하지 않는 이유
AAA *ptr = (AAA*)malloc(sizeof(AAA));

// malloc 함수를 호출 시, 실제로는 AAA 클래스의 크기 정보만 바이트 단위로 전달되기 때문에
// 생성자가 호출될 리 업사.
// 따라서, 객체를 동적으로 할당하려는 경우에는 반드시 new 연산자를 이용해야 한다.