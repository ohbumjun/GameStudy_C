<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>1.13</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="565b98b6-e75d-46c3-abd2-ee15bd9bbc6a" class="page sans"><header><h1 class="page-title">1.13</h1></header><div class="page-body"><hr id="c23efd59-765e-4388-924c-23f208e57001"/><ul id="b273f228-6be5-4953-88cb-26b600985de3" class="toggle"><li><details open=""><summary>C++</summary><ul id="e8797bc1-8c2a-44eb-b3f8-8240f5683953" class="toggle"><li><details open=""><summary><strong>12-2 Move 문법 ( move semantics ) , 완벽한 전달 ( perfect forwarding ), Referece Collapsing, Universal Reference ( 이어서 )</strong></summary><ul id="c56e8573-5914-4057-85c6-d30d4e0debbe" class="toggle"><li><details open=""><summary>문제 ( 다음 코드 실행 결과 )</summary><pre id="287e81df-f1a2-4b6d-9786-0b06030a04f6" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

class A {};

void g(A&amp; a) { std::cout &lt;&lt; &quot;좌측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp; a) { std::cout &lt;&lt; &quot;좌측값 상수 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(A&amp;&amp; a) { std::cout &lt;&lt; &quot;우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp;&amp; a) { std::cout &lt;&lt; &quot;const 우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }

int main() {
	A a;
	const A ca;

	std::cout &lt;&lt; &quot;원본 --------&quot; &lt;&lt; std::endl;
	g(a);
	g(ca);
	g(A());
	g(std::move(ca));

}</code></pre><ul id="3e68503a-7897-4bc9-bcc1-8d3d4be691cd" class="toggle"><li><details open=""><summary>정답</summary><pre id="4be4aef1-b518-4677-8e3f-d22d21d8a528" class="code"><code>원본 --------
좌측값 레퍼런스 호출
좌측값 상수 레퍼런스 호출
우측값 레퍼런스 호출
const 우측값 레퍼런스 호출</code></pre></details></li></ul></details></li></ul><ul id="ad6665ef-341f-4a21-8195-8bc9da019695" class="toggle"><li><details open=""><summary>문제 ( std::move )</summary><pre id="7f1f61e4-2f7d-40b5-962c-39279e17d8b8" class="code"><code>class A {
 public:
  A() { std::cout &lt;&lt; &quot;ctor\n&quot;; }
  A(const A&amp; a) { std::cout &lt;&lt; &quot;copy ctor\n&quot;; }
  A(A&amp;&amp; a) { std::cout &lt;&lt; &quot;move ctor\n&quot;; }
};

class B {
 public:
  A a_;
};

// B 객체를 생성할 때, 이미 생성되어 있는 A 객체를 B의 객체 안으로 넣고 싶다면 ?
int main() {
  A a;

  std::cout &lt;&lt; &quot;create B-- \n&quot;;
  B b(/* ?? */);
}</code></pre><ul id="dd30d8b5-6032-49e3-a8dc-2942f7d457ac" class="toggle"><li><details open=""><summary>문제 1-1</summary><pre id="cbee4314-4351-4931-809c-7401920b1013" class="code"><code>#include &lt;iostream&gt;

// 첫번째 Case
class B {
 public:
  B(const A&amp; a) : a_(a) {}

  A a_;
};

int main() {
  A a;
  std::cout &lt;&lt; &quot;create B-- \n&quot;;
  B b(a);
}

// 두번째 Case
class B {
 public:
  B(const A&amp; a) : a_(std::move(a)) {}

  A a_;
};

int main() {
  A a;
  std::cout &lt;&lt; &quot;create B-- \n&quot;;
  B b(a);
}

// 3번째 ? 
class B {
 public:
  B(A&amp;&amp; a) : a_(a) {}

  A a_;
};

int main() {
  A a;
  std::cout &lt;&lt; &quot;create B-- \n&quot;;
  B b(std::move(a));
}</code></pre><ul id="9aac5c4e-d350-4b1b-b333-95f2b9664cb8" class="toggle"><li><details open=""><summary>각각의 결과</summary><p id="706aeb7a-a6f2-4e00-8ee4-b489d31cba88" class=""><strong>1번째는</strong>, 그저 평소대로 복사 생성자를 호출할 것이다.</p><p id="1c440bf7-adda-4ee4-9434-ccd6a8b7c73d" class="">우리가 원하는 것은 이미 생성된 A 객체를 새로 생성된</p><p id="e6874e74-d49f-4a61-9ce6-48bfa888dab6" class="">b의 안으로 이동시키고 싶은 것이다.</p><p id="f8aae5cd-bd7e-45d0-8d08-d7259af6eda1" class="">
</p><p id="f85275c0-9abf-4d24-83fb-48f91800d44a" class=""><strong>2번째는</strong> ?</p><p id="cc4a8a95-e377-406b-b653-d2afec9bfe93" class="">여전히 복사 생성자를 호출하게 될 것이다. </p><p id="34e6b5fd-dcaa-4464-967b-0059af8ccb84" class="">std::move(a)를 통해 우측값으로 넘겨준 것은 맞다</p><p id="e6b404ce-5129-42b0-9331-4deec2d155c7" class="">그런데 a가 const A&amp; 이므로,</p><p id="e8c1e2f2-c368-42e9-afaf-07c2e751ad51" class="">std::move(a)의 타입은, const A&amp;&amp;가 된다.</p><p id="d3cc06ad-917b-470d-899e-839712a0ee4a" class="">그런데 A의 생성자에는 const A&amp;, A&amp;&amp; 2개 밖에 없다.</p><p id="0d40928f-20d6-4cde-aaa1-b279a680ffec" class="">따라서 컴파일러는 const A&amp;를 택하게 된다.</p><p id="629b3c59-a286-4fe3-8290-057edcc0286b" class="">복사 생성자를 호출하는 것이다. </p><p id="5a758fa8-ef0e-4e57-a111-553542274226" class="">
</p><p id="7cd48c9d-f67a-47a0-acab-a49bfee0bd4b" class=""><strong>3번째는 ?</strong></p><p id="4e14ffe8-41d6-48fc-9d8a-805f8c862533" class="">여전히 복사 생성자 </p><p id="0da21f79-89ed-4cd0-9ac9-5902f1748748" class=""><strong>B(A&amp;&amp; a)</strong></p><p id="6a54574b-4e63-4630-9e1e-03654ceb615d" class="">까지는 우측값 레퍼런스로 받았지만</p><p id="165fc889-2a2d-4cf7-91c5-c986314beb63" class="">a 는 그 자체로 좌측값이기 때문이다 ( 이름이 있으니까 )</p><p id="01e79efb-e2f8-436a-ac68-8ad6cedd1480" class="">따라서 a를 다시한번 우측값으로 캐스팅 시켜줘야 한다.</p><p id="578c5aed-ff7b-4f9b-92d6-1df8a18cb1a7" class="">
</p></details></li></ul><p id="fcc6399c-6188-4bca-828e-262b28530167" class="">
</p></details></li></ul><ul id="122b4a01-5f0a-4456-9392-643d7eece6f0" class="toggle"><li><details open=""><summary>정답</summary><pre id="88df238d-296d-4873-b2c2-dcf32320f246" class="code"><code>#include &lt;iostream&gt;

class A {
 public:
  A() { std::cout &lt;&lt; &quot;ctor\n&quot;; }
  A(const A&amp; a) { std::cout &lt;&lt; &quot;copy ctor\n&quot;; }
  A(A&amp;&amp; a) { std::cout &lt;&lt; &quot;move ctor\n&quot;; }
};

class B {
 public:
  B(A&amp;&amp; a) : a_(std::move(a)) {}

  A a_;
};

int main() {
  A a;
  std::cout &lt;&lt; &quot;create B-- \n&quot;;
  B b(std::move(a));
}</code></pre><p id="c27fc7a9-cd6a-4e1a-8f62-4f5fe33a6ded" class="">a를 우측값 레퍼런스로 받고</p><p id="a55d01fc-fd51-4647-88ee-35fd847704ea" class="">동시에 멤버 이니셜라이저에서</p><p id="c82fd26e-c77d-4c7c-addf-790fc9e7b1e3" class="">a를 다시 한번 우측값으로 캐스팅 시켜줘야 한다.</p></details></li></ul></details></li></ul><ul id="8efee4ab-8afc-462c-b40d-d1a573adf616" class="toggle"><li><details open=""><summary>문제 2</summary><pre id="cb0b12d0-a842-40a7-9c50-dce768164497" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void wrapper(T u) {
  g(u);
}

class A {};

void g(A&amp; a) { std::cout &lt;&lt; &quot;좌측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp; a) { std::cout &lt;&lt; &quot;좌측값 상수 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(A&amp;&amp; a) { std::cout &lt;&lt; &quot;우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }

int main() {
  A a;
  const A ca;

  std::cout &lt;&lt; &quot;원본 --------&quot; &lt;&lt; std::endl;
  g(a);
  g(ca);
  g(A());

  std::cout &lt;&lt; &quot;Wrapper -----&quot; &lt;&lt; std::endl;
  wrapper(a);
  wrapper(ca);
  wrapper(A());
}</code></pre><ul id="76867e89-4d84-4d75-9f3a-1ab3809ea12f" class="toggle"><li><details open=""><summary>결과 + 이유</summary><pre id="60d8884b-fda4-443c-bcff-0ceb8939143b" class="code"><code>원본 --------
좌측값 레퍼런스 호출
좌측값 상수 레퍼런스 호출
우측값 레퍼런스 호출
Wrapper -----
좌측값 레퍼런스 호출
좌측값 레퍼런스 호출
좌측값 레퍼런스 호출</code></pre><p id="4daa8f53-fb68-4400-ad4d-9c51c427a7a5" class="">왜냐하면, C++ 컴파일러가 템플릿 타입을 추론할 때</p><p id="a9fb8214-c394-4d7e-8869-e3bf9ee7eeec" class=""><strong>템플릿 인자 T가 레퍼런스가 아닌 </strong></p><p id="d8e06827-9708-448c-86e1-3db7ba75cec9" class=""><strong>일반적인 타입이라면</strong></p><p id="a12a450d-6088-4323-918e-b6ab15803a43" class=""><strong>const를 무시하기 때문이다.</strong></p><p id="f2838604-049d-4edf-a36d-a88e1e23d2fb" class="">
</p><p id="2e58747d-be9b-4252-8c8f-42300cf1a4e5" class=""><strong>즉,</strong></p><pre id="51689dbb-48e1-45ae-aa29-7896adefa0d9" class="code"><code>template &lt;typename T&gt;
void wrapper(T u) {
  g(u);
}</code></pre><p id="d6d7e324-f028-43c9-b05f-9015fb32ebca" class="">에서,<strong> T가 전부다 class A로 추정된다.</strong></p><p id="c91be3f0-7e65-46b3-80a4-a981c1153380" class="">따라서 3가지 경우 모두</p><p id="9a8de2e2-a9c9-4079-bfb9-a3af5aa3e1ae" class="">좌측값 레퍼런스를 호출하는</p><p id="37ff39c3-71c1-409d-9d27-63e46f79abaa" class="">g를 호출하였습니다.</p></details></li></ul></details></li></ul><ul id="b6637fcf-667c-4886-a2a6-e5bac1b4da44" class="toggle"><li><details open=""><summary>문제 3</summary><pre id="14517281-6cc6-4e4b-96c7-b6136636ecea" class="code"><code>template &lt;typename T&gt;
void wrapper(T&amp; u) {
  g(u);
}

int main() {
  A a;
  const A ca;
  std::cout &lt;&lt; &quot;Wrapper -----&quot; &lt;&lt; std::endl;
  wrapper(a);
  wrapper(ca);
  wrapper(A());
}</code></pre><p id="45707d7f-d983-40ad-bd52-78b0bc08bafa" class="">이때 발생하는 현상 ?</p><ul id="6616467d-ed8b-4abf-8cf1-81f0f38c3796" class="toggle"><li><details open=""><summary>답 + 이유</summary><pre id="4bc09a6b-1904-4e72-94bd-abeed99d31ea" class="code"><code>g(A()); 에서 오류가 발생한다.

error: cannot bind non-const lvalue reference of type &#x27;A&amp;&#x27; 
to an rvalue of type &#x27;A&#x27;
  wrapper(A());</code></pre><p id="7bf6b999-5cc3-4347-aef0-1eb9b04a9689" class="">A( ) 자체는 const 속성이 없으므로 → A( ) 자체는 우측값이다. ( 임시 객체 )</p><p id="c776f55c-1b2e-45f7-a31b-6ce697c32ca0" class="">템플릿 인자 추론에서 T가 class A로 추론된다.</p><p id="110fa268-5ded-4c41-8ca6-6902dffcf2c6" class="">하지만 A&amp;는 우측값의 레퍼런스가 될 수 없기 때문에</p><p id="49be6142-a056-471f-b0f8-29828c6ac49b" class="">컴파일 오류가 발생하는 것이다.</p></details></li></ul></details></li></ul><ul id="6c1307f0-ba8f-47d4-9f52-eedc02c65ce2" class="toggle"><li><details open=""><summary>문제 4</summary><pre id="b90e9cac-e336-4053-b097-e01bd8cd4427" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void wrapper(T&amp; u) {
  std::cout &lt;&lt; &quot;T&amp; 로 추론됨&quot; &lt;&lt; std::endl;
  g(u);
}

template &lt;typename T&gt;
void wrapper(const T&amp; u) {
  std::cout &lt;&lt; &quot;const T&amp; 로 추론됨&quot; &lt;&lt; std::endl;
  g(u);
}

class A {};

void g(A&amp; a) { std::cout &lt;&lt; &quot;좌측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp; a) { std::cout &lt;&lt; &quot;좌측값 상수 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(A&amp;&amp; a) { std::cout &lt;&lt; &quot;우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }

int main() {
  A a;
  const A ca;

  std::cout &lt;&lt; &quot;원본 --------&quot; &lt;&lt; std::endl;
  g(a);
  g(ca);
  g(A());

  std::cout &lt;&lt; &quot;Wrapper -----&quot; &lt;&lt; std::endl;
  wrapper(a);
  wrapper(ca);
  wrapper(A());
}</code></pre><ul id="b19ca193-5051-4a8b-8cb5-b10a133e0465" class="toggle"><li><details open=""><summary>답변 + 이유</summary><pre id="ef0a1393-516c-4132-9905-0a0ed4a6295c" class="code"><code>원본 --------
좌측값 레퍼런스 호출
좌측값 상수 레퍼런스 호출
우측값 레퍼런스 호출
Wrapper -----
T&amp; 로 추론됨
좌측값 레퍼런스 호출
const T&amp; 로 추론됨
좌측값 상수 레퍼런스 호출
const T&amp; 로 추론됨
좌측값 상수 레퍼런스 호출</code></pre><p id="103afb50-bb4b-4228-9b0f-d3b0959fb7d9" class="">a와 ca의 경우, 각각 T&amp;, const T&amp;로 잘 추론되어서</p><p id="c14bc6d3-0c6d-4e1d-af5e-3ee78edeba1c" class="">올바른 함수를 호출한다.</p><p id="c5ea9bc8-cc29-4df1-8c04-010da9d5b0c0" class="">반면 A( ) 경우, const T&amp;로 호출된다. 따라서 g( const T&amp;)를 호출한다.</p><p id="93bfb72f-7aa0-4289-b241-4d03cee81230" class="">왜냐하면, wrapper 안의 u 자체는 좌측값이기 때문이다.</p><p id="d1896052-f649-4f02-85e9-6aedaeeeae5f" class="">따라서 좌측값 레퍼런스를 받는 함수들이 오버로딩 될 것ㅇ다.</p></details></li></ul></details></li></ul><ul id="2fea34c9-09c1-4fee-99ec-8b5f8c02a0df" class="toggle"><li><details open=""><summary>문제 5</summary><pre id="81f3bfbd-028c-4de0-9cca-a3b0f241c97c" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void wrapper(const T&amp; u) {
	std::cout &lt;&lt; &quot;const T&amp; 로 추론됨&quot; &lt;&lt; std::endl;
	g(u);
}

class A {};

void g(A&amp; a) { std::cout &lt;&lt; &quot;좌측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp; a) { std::cout &lt;&lt; &quot;좌측값 상수 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(A&amp;&amp; a) { std::cout &lt;&lt; &quot;우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }

int main() {
	A a;
	const A ca;

	std::cout &lt;&lt; &quot;원본 --------&quot; &lt;&lt; std::endl;
	g(a);
	g(ca);
	g(A());

	std::cout &lt;&lt; &quot;Wrapper -----&quot; &lt;&lt; std::endl;
	wrapper(a);
	wrapper(ca);
	wrapper(A());
}</code></pre><ul id="4162f7fa-a1bb-46b6-820b-3ebaef89ac2c" class="toggle"><li><details open=""><summary>결과 + 이유</summary><pre id="2746c9d3-0509-4697-8cbc-3f8572aa30ca" class="code"><code>원본 --------
좌측값 레퍼런스 호출
좌측값 상수 레퍼런스 호출
우측값 레퍼런스 호출
Wrapper -----
const T&amp; 로 추론됨
좌측값 상수 레퍼런스 호출
const T&amp; 로 추론됨
좌측값 상수 레퍼런스 호출
const T&amp; 로 추론됨
좌측값 상수 레퍼런스 호출</code></pre><p id="2207f0d2-4ca2-41d0-a3b7-b4aef310e241" class="">상수 레퍼런스만 wrapper 함수의 인자로 받으면</p><p id="e7c2e879-df31-4636-96cf-1f219209de2b" class="">상수가 아닌 레퍼런스도 상수 레퍼런스로 캐스팅되어 들어가버린다.</p><p id="05087e43-634e-4a0b-9024-d63e8295aa0f" class="">
</p></details></li></ul></details></li></ul><ul id="0c64f240-ca73-40ba-8507-3b2e3bf11e0c" class="toggle"><li><details open=""><summary>문제 6</summary><p id="0ed11e01-3ad2-4c55-b880-870c05c1bc1c" class="">함수  g가 인자 2개를 받는 다고 가정했을 때</p><p id="af596c00-b2a0-482c-a759-8a4c0eccecee" class="">아래와 같이 모든 조합의 템플릿 함수들을 정의해야 하는이유2가지</p><pre id="431c5b4f-eaaa-45e2-a37d-c671e1fa3419" class="code"><code>template &lt;typename T&gt;
void wrapper(T&amp; u, T&amp; v) {
  g(u, v);
}
template &lt;typename T&gt;
void wrapper(const T&amp; u, T&amp; v) {
  g(u, v);
}

template &lt;typename T&gt;
void wrapper(T&amp; u, const T&amp; v) {
  g(u, v);
}
template &lt;typename T&gt;
void wrapper(const T&amp; u, const T&amp; v) {
  g(u, v);
}</code></pre><p id="c8ce8abf-f514-4618-9124-7fcd3fffd7e8" class="">
</p><p id="1579f0ec-d5ed-47ad-9e89-c7ea22ed3b92" class="">1) 일반적인 레퍼런스가 우측값을 받을 수 없기 때문이다</p><pre id="397531a3-2efa-4aba-98a1-beb64e604391" class="code"><code>wrapper(T&amp;u ) ~ wrapper(A())  문제 !</code></pre><p id="0692d455-4006-46f1-aae7-64be075e8dd5" class="">
</p><p id="b65f6232-6957-4a68-847f-2f0ed3ec2d44" class="">2) 그렇다고 모두 상수 레퍼런스만 받아버리면, 상수가 아닌 레퍼런스도</p><p id="a28cd3fb-2d46-45f6-8a02-8781ac3ee456" class="">상수 레퍼런스로 캐스팅되어 들어간다.</p><p id="8ed94b6d-865f-4c8f-b078-dfe4536f1c87" class="">
</p></details></li></ul><ul id="89414ae3-035c-4ab9-82b2-87ff570cde92" class="toggle"><li><details open=""><summary>문제 7</summary><pre id="3dc8b6db-a981-46bd-b66a-6c6859a1d860" class="code"><code>template &lt;typename T&gt;
void wrapper(T&amp;&amp; u) {
	g(std::move(u));
}

class A {};

void g(A&amp; a) { std::cout &lt;&lt; &quot;좌측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp; a) { std::cout &lt;&lt; &quot;좌측값 상수 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(A&amp;&amp; a) { std::cout &lt;&lt; &quot;우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }

int main() {
	A a;
	const A ca;

	std::cout &lt;&lt; &quot;원본 --------&quot; &lt;&lt; std::endl;
	g(a);
	g(ca);
	g(A());

	std::cout &lt;&lt; &quot;Wrapper -----&quot; &lt;&lt; std::endl;
	wrapper(a);
	wrapper(ca);
	wrapper(A());
}</code></pre><ul id="f554860c-7ec9-4bf1-876b-a650122a8f5f" class="toggle"><li><details open=""><summary>결과</summary><pre id="cc382537-0a86-4461-b1d4-8173bb59be32" class="code"><code>원본 --------
좌측값 레퍼런스 호출
좌측값 상수 레퍼런스 호출
우측값 레퍼런스 호출
Wrapper -----
우측값 레퍼런스 호출 // std::move 적용
좌측값 상수 레퍼런스 호출 // const T&amp;&amp; 형태로 들어오는데, 그에 해당하는
// 생성자가 정의되어 있지 않아서 const T&amp;, 즉, 복사 생성자 호출
우측값 레퍼런스 호출 // std::move 적용
</code></pre></details></li></ul></details></li></ul><ul id="982f53d2-65a5-4723-9498-10b50a3c01d3" class="toggle"><li><details open=""><summary>문제 7에 대한 해결책 </summary><pre id="d3573184-8ef6-4130-ad3b-3bad54afad2b" class="code"><code>#include &lt;iostream&gt;

// 우리의 목적은 하나다.
// lvalue로 들어오면, lvalue 참조로
// rvalue 참조로 들어오면 rvalue 참조로 
// 들어온 데이터를 있는 그대로 넘겨주는 것이 중요하다.
// 아래와 같이 forward를 쓰면, template 함수 하나만으로
// 둘의 기능을 구현하는 것이 가능하다.

template &lt;typename T&gt;
void wrapper(T&amp;&amp; u) {
  g(std::forward&lt;T&gt;(u));
}

class A {};

void g(A&amp; a) { std::cout &lt;&lt; &quot;좌측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp; a) { std::cout &lt;&lt; &quot;좌측값 상수 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(A&amp;&amp; a) { std::cout &lt;&lt; &quot;우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }

int main() {
  A a;
  const A ca;

  std::cout &lt;&lt; &quot;원본 --------&quot; &lt;&lt; std::endl;
  g(a);
  g(ca);
  g(A());

  std::cout &lt;&lt; &quot;Wrapper -----&quot; &lt;&lt; std::endl;
  wrapper(a);
  wrapper(ca);
  wrapper(A());
}

// 성공
원본 --------
좌측값 레퍼런스 호출
좌측값 상수 레퍼런스 호출
우측값 레퍼런스 호출
Wrapper -----
좌측값 레퍼런스 호출
좌측값 상수 레퍼런스 호출
우측값 레퍼런스 호출</code></pre></details></li></ul><hr id="ae57e014-f83d-4c2f-9eb3-2e033ffa7a50"/><p id="285cf97f-12a2-4723-ba16-12555debb243" class="">( 문제 7에 대한 해결책에 대한 설명들이 아래에 나온다 )</p><p id="474efe9f-546d-4a97-bc60-9b874020b6d5" class=""><strong>lvalueness or rvalueness</strong></p><ul id="f47327de-4bdd-454f-acb1-86b621ecd314" class="toggle"><li><details open=""><summary>의미</summary><p id="acc99a8c-4d80-49c0-8e9d-20de5f492cf4" class=""><strong>표현식이 lvalueness 또는 rvalueness를 가지느냐는 그것의 타입에 의존적</strong></p><p id="c765c3a8-0f4b-4bf5-b834-e066136712e7" class="">
</p><p id="e826949e-fff7-4f33-a33f-2e36c9281496" class="">표현식이 lvalue냐 rvalue냐는 그것의 타입에 의존적이기 때문에,
<strong>타입은 rvalue reference이지만, 표현식 자체(변수일 경우 해당 변수값)는 lvalue 또는 rvalue</strong>가 될 수 있다.</p><p id="bd1a6f96-d9f4-4813-93bd-78964f6512b6" class="">
</p><ul id="a3f4b7de-8b4a-4bba-a559-aa94cdc1e142" class="toggle"><li><details open=""><summary>문제 : 아래 코드 밑줄 부분의 <strong>타입과 표현식 자체</strong></summary><pre id="df71306f-b9b2-4747-ba5e-fa1e1b5ac39b" class="code"><code>template &lt;typename T&gt;
class Widget
{
    ...
    Widget(Widget&amp;&amp; rhs);   
    ...                     
};
 
template&lt;typename T1&gt;
class Gadget
{
    ...
    template &lt;typename T2&gt;
    Gadget(T2&amp;&amp; rhs);        
    ...                    
};</code></pre><ul id="53ce2210-b46b-4d7f-8fff-309ee3a98095" class="toggle"><li><details open=""><summary>답변</summary><pre id="41b8d4b3-abf7-41b4-a3db-b88c8c9d27f5" class="code"><code>template &lt;typename T&gt;
class Widget
{
    ...
    Widget(Widget&amp;&amp; rhs);    // rhs의 타입은 rvalue reference,
    ...                      // 하지만, rhs 자체는 lvalue
};
 
template&lt;typename T1&gt;
class Gadget
{
    ...
    template &lt;typename T2&gt;
    Gadget(T2&amp;&amp; rhs);        // rhs의 타입은 universal reference
    ...                      // 하지만, rhs 자체는 lvalue
};</code></pre></details></li></ul></details></li></ul></details></li></ul><hr id="3784fdc3-d668-4c1f-88ce-4fae7031529b"/><p id="4c8d9827-9675-4bf2-9d05-67d3b0f921b6" class=""><strong>Refence Collapsing </strong></p><ul id="d56dcdfb-d8a3-41b6-af25-70a0d2a73148" class="toggle"><li><details open=""><summary>특징</summary><p id="dcf6b5a5-6903-4f14-8dee-0572bc5e3f74" class="">C++11의 특정한 생성 과정에서 레퍼런스의 레퍼런스가 발생하지만, C++은 레퍼런스의 레퍼런스를 허용하지 않는다.</p><p id="6db6b3b5-45e9-49e0-9135-80c9b843be7c" class="">만약, <strong>소스코드 자체에 명시적으로 레퍼런스의 레퍼런스 형식을 포함한다면 그 코드는 유효한 코드가 아니다</strong>.</p><pre id="652297a1-c888-4b0c-adb2-fba3201ba832" class="code"><code>Widget w1;
// 에러! 레퍼런스의 레퍼런스 따윈 없는거임!
Widget&amp; &amp; w2 = w1;</code></pre><p id="e7cb5f0b-6394-4093-92fe-34dfe3f0b76a" class="">하지만, <strong>컴파일러가 타입을 추론하는 과정에서의 결과로써, 레퍼런스의 레퍼런스가 발생하는 경우들이 있다</strong>.</p><p id="0d97eb9b-6b69-44b3-8b96-914bae2f3069" class="">이렇게 발생한 레퍼런스의 레퍼런스에 대해 <strong>reference collapsing</strong>을 수행하게 되며,</p><p id="bc58cf7a-6c43-454d-ba4d-b5746ee8581a" class="">이것이 바로 <strong>universal reference가 lvalue reference 또는 rvalue reference로 해석될 수 있는 기본 메커니즘</strong>이다</p></details></li></ul><ul id="3cc7c3e5-6753-488e-aa5b-0d843b679f9a" class="toggle"><li><details open=""><summary>4가지 형태 및 결과</summary><pre id="cf91f298-9291-4992-bc95-dfe650053d01" class="code"><code>lvalue reference와 rvalue reference, 두 종류의 레퍼런스 종류로 인해 
4가지의 레퍼런스의 레퍼런스 조합이 존재할 수 있다.
&amp;    &amp;    (L + L)
&amp;    &amp;&amp;  (L + R)
&amp;&amp;  &amp;    (R + L)
&amp;&amp;  &amp;&amp;  (R + R)</code></pre><p id="490d4321-b24e-4f5b-9d39-b2ba8af236a1" class="">
</p><p id="f65dbcde-51a2-4049-aeaa-77ef3b2b153f" class=""><strong>( 결과 )</strong></p><pre id="3d255013-9339-4a36-9b97-b75843917375" class="code"><code>그리고, 두 가지의 reference collapsing 규칙이 다음과 같이 존재한다.
&amp;&amp;  &amp;&amp;  (R + R) 은 &amp;&amp;로 collapse 된다.
그 외 나머지 조합(L 이 하나라도 포함된)은 &amp;로 collapse 된다.

즉, 위 collapse 규칙을 적용하면 다음과 같이 된다.
&amp;    &amp;    (L + L) -&gt; &amp;
&amp;    &amp;&amp;  (L + R) -&gt; &amp;
&amp;&amp;  &amp;    (R + L) -&gt; &amp;
&amp;&amp;  &amp;&amp;  (R + R) -&gt; &amp;&amp;</code></pre><p id="24c9b2a1-1bdb-40bb-ac8b-3bab89be8af9" class="">즉, &amp;는 1, &amp;&amp;는 0으로 보고</p><p id="75ec380e-f5fb-425b-9f77-0a49972d42b7" class="">Or 연산을 한다고 생각하면 된다.</p></details></li></ul><hr id="49701ed8-d39c-4a52-bf01-df7883504780"/><p id="ee414b18-ccd8-41d8-8897-6998f9ef422a" class=""><strong>Reference Collapsing 과 template 함수</strong></p><ul id="a549e2cb-1d0d-4f81-9223-39a5e49824fd" class="toggle"><li><details open=""><summary>특징</summary><p id="a9f932fa-3e69-4634-b05f-bfb4d41574d9" class="">Universal reference 타입을 템플릿 인자로 받아 타입을 추론하는 과정에서, lvalue와 rvalue는 조금 다르게 타입이 추론된다.</p><p id="f78da16c-d835-46d5-8967-fb733db789f6" class=""><strong>T의 lvalue 타입은 T&amp;로써 추론되나, T의 rvalue 타입은 “참조 없이” 그냥 T로 추론</strong>된다.</p><p id="9fd9b862-d5af-4f7e-9ed6-7a82cb67ce10" class="">
</p><pre id="80e9680e-e411-4b11-83e9-458dd655e0bc" class="code"><code>template&lt;typename T&gt;
void func(T&amp;&amp; param);

-----------------------

Widget widgetFactory();

Widget w;

func(w); 

func(widgetFactory()); </code></pre><ul id="ca626493-6752-4767-870c-b644d5370441" class="toggle"><li><details open=""><summary>위 코드의 추론 결과</summary><pre id="ac50b2c2-5be6-4980-83ad-2e3e25efb275" class="code"><code>void func(Widget&amp; &amp;&amp; param); --&gt; void func(Widget &amp; param); 
// l-value 타입으로 func 함수 인자로 전달된다.

void func(Widget &amp;&amp; param);
// r-value 타입으로 func 함수 인자로 전달된다.</code></pre></details></li></ul><ul id="86885fb5-843b-40ad-b0d2-86fdb4df6813" class="toggle"><li><details open=""><summary>문제 : 아래 코드에서, 2개 함수 호출의 변환 형태</summary><pre id="4f51f061-eefb-4562-811f-1f412e35f06f" class="code"><code>template&lt;typename T&gt;
void f(T&amp;&amp; param);
 
int x;
 
// rvalue로 f 함수 호출
f(10);
// lvalue로 f 함수 호출
f(x);</code></pre><ul id="959c02d3-81d9-4b47-9fb4-1967be49c845" class="toggle"><li><details open=""><summary>답변</summary><pre id="7a4d864f-e0e5-4e9f-9c2a-2f9a5046ec6d" class="code"><code>// rvalue로부터 f 함수 instantiated
void f(int&amp;&amp; param);

------------------------------------------------------------

// lvalue로부터 f 함수 instantiated
void f(int&amp; &amp;&amp; param);
-&gt; 이 경우, 결과적으로 reference collapsing이 발생하여
// reference collapsing 이후 lvalue로부터 f 함수 instantiated
void f(int&amp; param);
로 인식된다.</code></pre></details></li></ul></details></li></ul><ul id="d751f3ef-83b7-4210-a3f6-5afa66edc0c3" class="toggle"><li><details open=""><summary>문제 2 : ~~ 동일</summary><pre id="24e44b68-96d2-4e3a-9c2c-8a53250830ef" class="code"><code>template&lt;typename T&gt;
void f(T&amp;&amp; param);
 
int x;
 
// r1의 타입은 int&amp;&amp;
int&amp;&amp; r1 = 10;
 
// r2의 타입은 int&amp;
int&amp; r2 = x;</code></pre><ul id="d1b59081-5b47-4d75-a198-5c974eb2dd1d" class="toggle"><li><details open=""><summary>답변 + 이유</summary><pre id="60596dbc-95b4-4b12-86ef-45640cf028c7" class="code"><code>f(r1);
f(r2);

즉, 둘다 최종적으로 param으로 넘어갈 때
모두 int&amp;로 추론된다

reference-stripping 으로 r1,r2는 그저 int로 간주되었고
r1,r2는 lvalue 표현식이 기 때문에
템플릿 함수 f의 최종 인자로 넘어갈땐 
universal reference 타입 추론 규칙에 의해
int&amp; 로 간주되는 것이다. </code></pre><p id="0deab9ea-bb0f-404b-84b6-c2732b3d24bf" class="">
</p><p id="986776bb-f0c2-4a3a-8f6d-b3227ace4788" class="">변수의 타입이 레퍼런스인 경우에는</p><p id="b5389735-6cd0-46e3-900e-117037f2b75f" class="">타입의 레퍼런스 부분이 무시 ( reference-stripping) 된 채 처린된다.</p><p id="30fd8217-6868-4697-b743-4dd447b25d50" class="">
</p><p id="e28adc83-14a7-4726-a707-961fccafd4a0" class="">즉, r1, r2 모두 레퍼런스 부분이 무시되고</p><p id="496c72c7-a9e8-4735-b96d-824d99ea5ce8" class="">함수 f를 호출하는 과정에서 인자에서 먼저 int로 간주된다.</p><p id="3f3c6f56-08ca-4649-b172-bee9d6a8ea33" class="">
</p><p id="dad73318-c95c-49f1-9136-27ae4e00248b" class="">레퍼런스 부분을 무시하고, 타입을 처리할 때는</p><p id="72d55e25-94d8-4390-a025-bfdf709cec7c" class="">universal reference의 타입을 lvalue는 T&amp;로 ,</p><p id="f25efb0e-8a1f-4c14-8e8a-81c415dd364d" class="">rvalue는 T로 추론하는 규칙으로부터 독립적이다.</p></details></li></ul></details></li></ul></details></li></ul><ul id="e09a738c-4acf-415a-90f8-0b53cbf40c7f" class="toggle"><li><details open=""><summary>문제 8_1 : T&amp;&amp; u ??</summary><pre id="168628e9-e7a2-4bdb-8c9e-f99833f0ceaf" class="code"><code>template &lt;typename T&gt;
void wrapper(T&amp;&amp; u) {
  g(std::forward&lt;T&gt;(u));
}
// 위의 형태를 부르는 명칭 ?</code></pre><ul id="7c8407f8-fbb6-43ee-a5ba-e31fe13f1c88" class="toggle"><li><details open=""><summary>답변</summary><p id="67d9f825-a674-41c9-a61a-3dd1795fc477" class="">템플릿 인자 T에 대해서 우측값 레퍼런스를 받는 형태를</p><p id="8b36cd39-67b0-4691-8830-136ebcdf10bf" class=""><strong>보편적 레퍼런스 ( Universal Referece ) </strong>라고 한다.</p><p id="5ded0962-5496-4c16-9287-258d0e732802" class="">보편적 레퍼런스는 우측값만 받는 레퍼런스와 다르다.</p></details></li></ul><ul id="4bb2aa46-99d2-4872-97d1-653a0e2156c3" class="toggle"><li><details open=""><summary>그냥 T&amp;&amp; 와 다른점 ?</summary><pre id="b5f6cd18-1ac4-4194-9169-5e8cfe2953fe" class="code"><code>#include &lt;iostream&gt;

void show_value(int&amp;&amp; t) { std::cout &lt;&lt; &quot;우측값 : &quot; &lt;&lt; t &lt;&lt; std::endl; }

int main() {
  show_value(5);  // 우측값 ok!

  int x = 3;
  show_value(x);  // 애러
}</code></pre><p id="e078de9a-e230-46b7-b728-0d90af0f0f18" class=""><strong>일반 우측값 레퍼런스는 우측값만을 인자로 받을 수 있다</strong></p><p id="3464612d-ae0f-44a5-b29b-2c906c243fc0" class="">하지만, </p><pre id="605dc69d-ea47-4420-9d22-a4d4fa70b341" class="code"><code>template &lt;typename T&gt;
void wrapper(T&amp;&amp; u) {</code></pre><p id="e840a688-f6b3-4c9f-9d67-8b1f41584354" class="">템플릿 인자의 우측값 레퍼런스는</p><p id="3f4966af-0355-4336-b164-2f26d4aef8cc" class=""><strong>우측값 뿐만 아니라, 좌측값 역시 받아낼 수 있습니다.</strong></p><p id="e6a9811f-8d62-4b07-8620-f9393a5c50d7" class="">
</p></details></li></ul><p id="d81483c3-475c-4db1-9021-569f099aa68d" class="">
</p><p id="1cbcae69-a5bc-4370-87d2-e78ace83e344" class=""><strong>r-value, universal - reference  여부를 맞춰보자 !</strong></p><ul id="4bf35369-497a-4bbd-b908-83845ef5a2bf" class="toggle"><li><details open=""><summary>추가 문제</summary><figure id="2060294f-a253-4b7d-ab13-be8206d53ab0" class="image"><a href="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled.png"><img style="width:310px" src="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled.png"/></a></figure><ul id="3b1a5a75-ba06-404d-acde-9205be9b7eed" class="toggle"><li><details open=""><summary>각각 r-value, universal - reference 중 어떤 거 ?</summary><figure id="a7d2f00e-fde6-4284-ad1c-66a9c03d49dd" class="image"><a href="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled%201.png"><img style="width:848px" src="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled%201.png"/></a></figure><p id="3ffba5e8-72b8-4412-8145-c2e79dd02d20" class="">즉, 타입을 추론해야 하는 경우 &amp;&amp; 는 universal reference 이고 </p><p id="e8045bb9-d3cf-4688-8cad-7aa5f87620c0" class="">타입이 명시되어 있는 경우에는 &amp;&amp;가 rvalue reference 인 것이다.</p></details></li></ul></details></li></ul><ul id="345a92f2-1936-484d-bdf6-f0593666f01f" class="toggle"><li><details open=""><summary>추가 문제 2</summary><pre id="50e690cf-95ee-4484-84f5-cde0ccebbc9f" class="code"><code>template &lt;typename T&gt;
void f(std::vector&lt;T&gt;&amp;&amp; param); </code></pre><ul id="227daff5-b62b-4787-8f18-d79823ab7fc5" class="toggle"><li><details open=""><summary>답변</summary><pre id="1457170e-1a22-43ec-9973-8b87a0e6bb73" class="code"><code>위 f 함수의 인자는 추론해야 할 타입 T도 있고, &quot;&amp;&amp;&quot;도 붙어있다.

하지만, T&amp;&amp;가 아닌 std::vector&lt;T&gt;&amp;&amp;이므로 이 녀석의 타입은 
명시적으로 std::vector&lt;T&gt;에 대한 &amp;&amp;이다.

따라서, universal reference가 아닌 일반적인 rvalue reference인 것이다.</code></pre></details></li></ul><p id="78fa98a1-67a6-4f3c-a94a-6a94a16607da" class="">
</p></details></li></ul><ul id="38dba255-db1c-42e3-8833-33c9bbd550e7" class="toggle"><li><details open=""><summary>추가 문제 3</summary><pre id="c43cdcc3-7a94-4ccf-b238-f74b6c62b6cf" class="code"><code>template &lt;typename T&gt;
void f(const T&amp;&amp; param);</code></pre><ul id="f04c9a99-781b-4115-a6c4-52ae0ce474c4" class="toggle"><li><details open=""><summary>답변</summary><pre id="b8d04640-b34b-4b53-9d32-462b09d88b6d" class="code"><code>Universal reference가 템플릿 함수 인자로 사용될 때엔 
반드시 &quot;T&amp;&amp;&quot;의 형태여야 한다.

여기에 const 한정자만 가져다 붙여도 
&quot;&amp;&amp;&quot;는 universal reference로 해석되지 않는다.</code></pre></details></li></ul></details></li></ul><ul id="a3359de7-b9f5-45f5-816d-75f5cb7583a1" class="toggle"><li><details open=""><summary>추가 문제 4</summary><pre id="7c91212e-1719-4b19-a317-745c7241ef62" class="code"><code>template &lt;typename T, type Allocator = allocator&lt;T&gt; &gt;
class vector
{
public:
    ...
    void push_back(T&amp;&amp; x);    
};</code></pre><ul id="a8174ce7-0770-4700-b7b2-3af57230dcfc" class="toggle"><li><details open=""><summary>답변</summary><pre id="6f26624e-bcf9-44af-8234-154105df4616" class="code"><code>T가 템플릿 인자이고, 
템플릿 함수 인자가 T&amp;&amp;여도 T에 대한 
타입 추론이 발생하지 않는 경우도 있다.

std::vector&lt;T&gt;의 객체가 생성되기 위해, 
instantiate 되는 과정에서 T는 이미 타입 추론이 완료되었기에, 

push_back이 호출되는 시점에서 
다시 T에 대한 타입 추론을 할 필요가 없는 것이다.
따라서, push_back의 &quot;T&amp;&amp;&quot;는 universal reference가 아닌, 
rvalue reference 이다.</code></pre></details></li></ul><ul id="ee1d1d51-ce22-41e1-b96e-3f13fc2749a7" class="toggle"><li><details open=""><summary>예시</summary><pre id="d19523f5-9c51-477a-ab26-43385b56fe16" class="code"><code>// Widget 객체를 생성하는 팩토리 함수
Widget makeWidget();
 
// Widget 벡터 생성
std::vector&lt;Widget&gt; vw;
 
Widget w;
 
// 이 함수를 풀어쓰면 다음과 같다.
// std::vector&lt;Widget&gt;(Widget&amp;&amp; w);
// 이미 이 시점에서 Widget 타입이라는 것이 명시되어 있으므로, 타입 추론할 필요가 없다.
vw.push_back(makeWidget());</code></pre></details></li></ul></details></li></ul><p id="f8b55db3-523d-4a7f-b48f-037a3e259be7" class="">
</p><pre id="7e840c20-7f73-4900-94a7-ba3aa4118ae6" class="code"><code>wrapper(a);
wrapper(ca);
wrapper(A());</code></pre><ul id="ff35661a-19e3-4b74-b3ca-b69ebfb45205" class="toggle"><li><details open=""><summary>문제 : 각각 어떤 식으로 추론될까 ?</summary><pre id="4fceed78-703d-40a2-9124-080f0c3af0b5" class="code"><code>위 2개는 타입 T가 l-value&amp; 로 추론되고
아래 1개는 타입 T가 그냥 단순히 T 형태로 ( 참조 형태 없이 )

이후, wrapper 에 인자로 전달되는 형태로는

void wrapper(T&amp; u) // l-value는 최종적으로 l-value &amp; 형태로 전달
void wrapper(T&amp; u)

void wrapper(T&amp;&amp; u) // r-value는 최종적으로 r-value &amp; 형태로 전달</code></pre></details></li></ul><p id="26ae98dc-21b4-4ca7-83db-e55238ee8c04" class="">
</p></details></li></ul><hr id="6bb54f5a-e750-4e31-b2f9-d7c06ba378a7"/><p id="16b9c3d0-5b40-43d0-9b5a-0f818bde95d6" class=""><strong>std::forward </strong></p><ul id="4735b3e9-f1b4-47ce-a2a8-118d8cbd9005" class="toggle"><li><details open=""><summary>std::forward의 목적</summary><pre id="39da05b1-61c3-4661-9823-fe27f5d89378" class="code"><code>template&lt;typename T&gt;
void f(T&amp;&amp; param){
    ...
    someFunc(std::forward&lt;T&gt;(param));
}

std::forward는 들어온 universial reference가 
추론된 형태 그대로를 다른 함수에게 전달해줘야한다. </code></pre><ul id="10e6cfc2-cd95-4711-a12f-d89021a5f8dd" class="toggle"><li><details open=""><summary>다음 코드의 변환 형태 </summary><pre id="1da1006b-afc3-48f9-b9f8-36cc1f7c01dc" class="code"><code>template&lt;typename T&gt;
void f(T&amp;&amp; param){
    ...
    someFunc(std::forward&lt;T&gt;(param));
}

Widget widgetFactory();
Widget w;
func(w);
func(widgetFactory()); </code></pre><ul id="eda01a36-8b13-4b6d-9123-2a83c0f1559d" class="toggle"><li><details open=""><summary>답변</summary><pre id="af8fac2f-3f5a-48f4-855c-53ce725b5c3d" class="code"><code>
위에서 언급한 T와 universial reference의 관계를 생각해보면, 
universial reference가 Widget&amp; 인 경우 T는  Widget&amp; 이고

std::forward&lt;T&gt; 는 std::forward&lt;Widget&amp;&gt; 로 인스턴싱 될 것이다.

universial reference가 Widget&amp;&amp; 인 경우 T는  Widget 이고

std::forward&lt;T&gt; 는 std::forward&lt;Widget&gt; 로 인스턴싱 될 것이다.</code></pre><p id="64d58cda-a9dc-4613-9860-65844ca5dcb2" class="">
</p></details></li></ul></details></li></ul></details></li></ul><ul id="1f4167bd-8bd9-499a-a706-969d77239b80" class="toggle"><li><details open=""><summary>std::forward 형태</summary><pre id="eae79d49-77b0-4d93-9f2a-ee796df2cb3b" class="code"><code>template&lt;typename T&gt;
T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; param)
{ return static_cast&lt;T&amp;&amp;&gt;(param); }
</code></pre></details></li></ul><ul id="2ec7f905-b24d-4de6-8395-d11cd016d54a" class="toggle"><li><details open=""><summary>std::move, std::forward의 공통점</summary><p id="2e4c330e-19ff-445d-a39b-7ac5daefbbc7" class="">std::move가 실제로 객체를 move시키지 않고, std::forward도 실제로 객체를 forward하지 않는다. 이들 함수는<strong> 단순히 캐스팅을 수행하는 함수(함수 템플릿)일 뿐</strong>이다</p></details></li></ul><ul id="dcbc110f-2566-41da-a176-0935211a1a6b" class="toggle"><li><details open=""><summary>std::move, std::forward 의 차이점</summary><p id="02568e41-7e23-46dc-8051-dff6cc6bc5fa" class=""><strong>일반적으로, rvalue 참조에는</strong></p><p id="5bac1b36-0ea7-4546-a4fd-cd3aaee24b21" class=""><strong>std::move 를 사용하고</strong></p><p id="82054fcd-3d64-476e-ab59-13787b8fe667" class=""><strong>universal 참조에는 std::forward를 통해서 전달한다.</strong></p><p id="bc016009-2cbc-4e28-97a3-c85b37b89ea3" class="">
</p><p id="02ac5c53-314e-45a5-8f89-97025dfbaeff" class="">std::move는 무조건 인자로 넘어온 값을 rvalue reference로 캐스팅해주고, std::forward는 특정한 조건이 만족될 경우에만 인자로 넘어오는 값을 rvalue reference로 캐스팅해준다.</p></details></li></ul><ul id="b2f1cf82-df21-4b55-9c32-480540b9abe7" class="toggle"><li><details open=""><summary>std::move 의 역할</summary><p id="c5c0ce6e-af2a-43df-9ff5-39ef7e4764ef" class=""><strong>std::move은 전달된 파라미터를 강제로 r-value 참조로</strong></p><p id="1c697ec9-d4ae-4827-8a3f-4bf82c18cc80" class=""><strong>캐스팅하여 리턴하는 함수이다.</strong></p><p id="bc4e48fa-5c9b-463e-9b0d-b033e661d784" class="">
</p><pre id="9c955bc1-349e-4a24-9959-4f4e12438164" class="code"><code>Person p1(&quot;ahn&quot;, 1985);
// p1을 std::move를 통해서 이동연산이 가능하도록 캐스팅합니다.
Person p2= std::move(p1);

lvalue를 rvalue로 변환하여 이동생성자를 통해 p2를 생성한다.</code></pre></details></li></ul><ul id="85ef7a6e-9c56-4d76-ab62-c32d755ecb3c" class="toggle"><li><details open=""><summary>우측값이 이동의 후보가 될 수 없는 경우</summary><p id="a48fb4ef-7b07-44d3-b5dd-26958c3b2d7b" class="">바로</p><p id="2fbc06d0-1073-4fcd-9a83-407ebc1c2538" class=""><strong>const T 타입의 우측값</strong>이다.</p><p id="320fd2d8-a427-427d-8a01-512d3534a8d7" class="">
</p><p id="96fd7773-d71a-408c-8a55-1d4f4048a27f" class="">이동 생성자는 const가 아닌 T에 대한 우측값 참조를 받기 때문에</p><p id="be90ab9d-0a82-4167-b45c-7c871c9ba12a" class="">const T 타입의 우측값을 받을 수 없다.</p><p id="cb2b1dc7-3332-41e4-b5e2-6a1ce033aeea" class="">
</p><p id="3a718a59-6b3c-490f-a619-a05e72a4413f" class="">즉, 일반적으로 이동 생성자는 T ( T&amp;&amp; Obj ) 로 정의되어 있고</p><p id="530c9c3c-30ab-437b-b8f4-67aaba545f0d" class="">T ( const T&amp;&amp; Obj ) 로 정의되어 있지는 않다는 것이다.</p><p id="db115af4-d907-4d25-88ec-356c9681310d" class="">
</p><pre id="9d4b1d7f-51e1-4813-8815-c33b6b510733" class="code"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

class A {};

void g(A&amp; a) { std::cout &lt;&lt; &quot;좌측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp; a) { std::cout &lt;&lt; &quot;좌측값 상수 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(A&amp;&amp; a) { std::cout &lt;&lt; &quot;우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }
void g(const A&amp;&amp; a) { std::cout &lt;&lt; &quot;const 우측값 레퍼런스 호출&quot; &lt;&lt; std::endl; }

int main() {
	A a;
	const A ca;

	std::cout &lt;&lt; &quot;원본 --------&quot; &lt;&lt; std::endl;
	g(a);
	g(ca);
	g(A());
	g(std::move(ca));

}</code></pre><p id="8f2212a3-1697-47f6-a4fb-58237b10507d" class="">
</p><p id="b3e0476d-de41-45dc-bbbf-2a62e2dfadd9" class="">위와 같이 </p><p id="455112b9-c9ab-41ac-a9ce-5f92b615a24d" class=""><strong>const &amp;&amp; 에 대한 이동 생성자</strong>를 정의한다면 모르겠지만</p><p id="02008656-825e-400c-ad9e-b50f6d0c1232" class="">표준 class 에서는 저와 같은 형식이 정의되어 있지 않다는 것이다.</p><p id="ab715711-111e-4a6a-8bb1-78d68695fa2c" class="">
</p><p id="3b7b31a7-729f-45f6-b7b5-95b80c53f04b" class="">따라서, <strong>const &amp;&amp; 에 대한 이동 생성자 </strong></p><p id="14da2f5f-0182-4cd3-9c68-1a2bd56eb5f1" class="">가 정의되어 있지 않은 class 에 대해서</p><p id="5805210e-3b84-41a9-adaf-6e00b2e84665" class="">const T 형태에 대한 std::move 를 할 경우에는</p><p id="b6d70fd5-4ac3-466b-bee0-9dcb5587cd2d" class="">이동 생성자가 아니라</p><p id="02e0ecbf-3ca1-46e8-9e5b-8d44afcc1073" class="">const T&amp; 복사 생성자 인자에 걸려서</p><p id="30518ccb-45b0-4d7c-b517-18606064104f" class="">이동이 아닌 복사의 과정이 발생하게 되는 것이다.</p><p id="efaddf8c-601a-4558-959b-ec399980c3b2" class="">
</p><pre id="7cda46e3-3628-4b9d-8d1e-75328a618535" class="code"><code>class Annotation {
public:
    explicit Annotation(const std::string text)
        : value(std::move(text)) {}

private:
    std::string value;
};</code></pre><p id="a1df2962-9b82-4cc4-98cf-2380c1f8b786" class="">컴파일 오류 없이 잘 실행은 되지만</p><p id="ff01d137-bdfe-4d64-9415-1e991bd7a526" class="">문제는 text가 value로 이동이 되는 것이 아니라</p><p id="da2b60fa-69ce-4ff9-8b3a-a34db3c9b3a1" class="">복사가 된다는 점이다.</p><p id="3843fd2f-148a-4654-8264-88ffaeb16ac0" class="">
</p><pre id="747f398e-3b21-4fd2-9c94-ae212f3321cd" class="code"><code>class string { 
public:                        
    string(const string&amp; rhs); // 복사 생성자
    string(string&amp;&amp; rhs); // 이동 생성자
};</code></pre><p id="fa87a42d-2a8b-410a-9f07-7bd28eeb114a" class="">왜냐하면 string class는 위와 같이 정의되어 있기 때문이다. </p><p id="f2c34032-09ba-46ed-9302-ea24e821b306" class="">
</p><p id="e3698494-0348-460a-bb99-bee375903567" class="">
</p></details></li></ul><ul id="5a65a865-698c-4ccd-a5ce-9e6255d1dd81" class="toggle"><li><details open=""><summary>std::move 로 부터의 결론 2</summary><p id="857b4f0f-defd-49a8-89cb-0f12523c29a4" class="">1번째 : 이동을 지원한 객체는 const로 선언하지 말아야 한다</p><p id="812581b8-3ace-4552-8358-eaadf96f699b" class="">const 객체에 대한 이동 요청은 소리 없이 복사 연산으로</p><p id="1cbf08d3-9cf0-4f98-8271-0699448baa12" class="">변환될 수도 있기 때문이다.</p><p id="7802bef6-4f42-4a46-92b2-2fd12efcdb8c" class="">
</p><p id="c21c3595-205c-4593-98d6-bc0b07c5e328" class="">2번째 : std::move는 실제 이동을 수행하지 않으며</p><p id="85a51bec-74b5-4c32-be3f-3f98fc2603f0" class="">그저 r-value 참조 형태로 캐스팅만 해준다.</p><p id="4c9c9802-5411-4af0-b800-ff9a31f1ce72" class="">단, 여기서도 r-value 참조 형태로 캐스팅 해준다고 해서</p><p id="a4735de3-1c25-49a9-add6-ee080d4ac456" class="">반드시 해당 객체가 이동이 된다는 보장이 없다.</p><p id="9e22b5ad-f791-41cd-941f-bc863f315f51" class=""> </p></details></li></ul><ul id="8df066cc-bdbb-4f44-bf5b-aa21c4e6d64c" class="toggle"><li><details open=""><summary>universal reference가 Widget&amp;인 경우와 Widget 인 경우의 차이점</summary><figure id="4db8fd27-4d88-40de-91f0-bceda0c0b7f2" class="image"><a href="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled%202.png"><img style="width:785px" src="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled%202.png"/></a></figure><figure id="e75b375b-d500-4e82-8192-b78827176445" class="image"><a href="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled%203.png"><img style="width:813px" src="1%2013%202060294fa2534b7dab13be8206d53ab0/Untitled%203.png"/></a></figure></details></li></ul></details></li></ul></details></li></ul></div></article></body></html>