# 1.22

---

- **DX**
    
    **( Old )**
    
    - 정점 셰이더 시스템 값들
        - 정점 셰이더 단계가 출력할 수 있는 새로운 시스템 값 2개
            - SV_ClipDistance, SV_CullDistance
        - 특성 , 사용 용도
            - 정점 셰이더를 비로산 **레스터화 이전 단계**들은, 모두 이 시스템 값들을 변경할 수 있다.
            - 이 값들은 레스터화기에서 **“절단(Clipping)” 과 “선별 제외(Culling == 선별)”**에 쓰인다.
        - 절단 , 선별에 사용되는 점과 평면 사이의 거리 공식 + 의미 3개
            
            ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled.png)
            
            이 거리가 양수이면, 점은 평면으로 나뉘는 2 공간 중에서
            
            법선이 가리키는 쪽의 공간에 있는 것이고
            
            0 이면, 평면 바로 위에 있는 것이다.
            
            음이면, 법선 벡터 반대쪽 공간에 있는 것이다.
            
            **( 평면의 법선 방향에 있는 공간을 평면의 안쪽, 그 반대 방향의 공간을**
            
            **평면의 바깥쪽. 이라고 부른다. )**
            
        - SV_CullDistance 작동 원리 5
            - 어떤 기본도형을 이후의 처리에서 안심하고 완전히 제외시킬 수 있으려면
            
            기본도형의 모든 정점 위치가 절단 공간을 정의하는 여섯 평면들 중 적어도 하나의 바깥쪽에 있어야 한다.
            
            그러면, 어차피 해당 기본 도형은 보이지 않을 것이므로, 안심하고 폐기할 수 있다.
            
            - 이 시스템값 의미소의 각 성분은, 한 선별 판정 평면과 정점 사이의 거리를 나타낸다.
            - 래스터화기 단계는 이 값들을 이용해서 절단 공간 선별 판정을 수행해서, **같은 레지스터 안에 음의 값이 있는, 모든 정점을 제거한다.**
            
            ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%201.png)
            
            - 예를 들어서, **clips 특성의 어떤 한 성분이 기본도형의 모든 정점에 대해 음수이면, 그 기본도형은 레스터화 연산에서 제외된다.**
            - 이 예의 경우, **cilps 특성에 최대 4개의 선별 판정 결과**를 담을 수 있다.
        - SV_ClipDistsance 3
            - 기본도형의 정점들 중 이 특성의 성분이 음인 것이 하나라도 있으면,
            
            그 성분을 이용해서 현재 기본도형에서 잘라낼 부분을 계산한다.
            
            - 레스터화에 의해 생성된 단편들의 SV_ClipDistance 시스템 값 읨소에 음의 값이 포함되는 경우는 없다.
            - SV_CullDistance 시스템 값 의미소에 음의 값이 포함되는 경우는 없ㄷ.ㅏ
            
            즉, SV_CullDistance에서는 기본도형이 통채로 포함되거나 제외되는 반면, SV_ClipDistance 에서는 기본도형의 일부만 절단.된다.
            
            ( SV_ClipDistance 특성이 음이 아닌 부분만 남도록 )
            
        - 공통 특성 3
            - 절단, 선별 의미소 특성들은 한 파이프라인 구성에서 최대 2개까지 사용할 수 있다
            - 그리고 특성단 최대 4개의 성분들을 포함할 수 있다.
            - 결과적으로, 8개의 평면을 절단이나 선별을 위해 사용할 수 있는 것이다.
            
            ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%202.png)
            
    
    **( New )**
    
    **3.6.3 테셀레이터 단계 처리 공정**
    
    주어진 영역 안에서 일련의 점들을 선택하고, 
    
    그 점들을 이용해서 기본도형들을 생성하고
    
    그 기본도형 들을 파이프라인의 다음 단계로 넘겨준다.
    
    - 표본 위치들 5개
        - 이전 단계에서 **지정된 영역 종류**와 **테셀레이션 계수들에 기초**해서
        
        테셀레이션 공정을 진행한다.
        
        - 공정은 크게 2 부분으로 나뉜다. **첫 부분에서는 적절한 개수**의
        
        삼**각형들을 생성하기 위한 테셀레이션 점들을 선택**한다.
        
        - 이때 가장자리 테셀레이션 계수들이 내부 테셀레이션 계수들보다
        
        더 큰 값이면, 영역의 내부의 점들보다 외곽변 쪽 점들이 더 많이 선택된다.
        
        반대로, 내부 테셀레이션 계수가 더 큰 값이면 
        
        영역의 외곽변 쪽의 점들보다 내부 쪽 점들이 더 많이 선택된다.
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%203.png)
        
        - **선택된 점들은, 현재 영역 안에서의 “좌표”들로만 식별**된다.
        
        이 좌표들은, **테셀레이터가 생성하는 유일한 자료**로, 전반적인 영역
        
        도형 안에서의 **위치만을 제공**한다. 해당 단계는 즉,
        
        **영역 설정**과 **일단의 테셀레이션 계수**들을 받아서, 이후에 필요한
        
        모든 **표본점 위치들을 산출**한다.
        
        - 그 위치들을 제어 패치.에 기초해서 **실제 정점들로 변환**하는 것은
        
        **테셀레이터 단계가 아니라, 영역 셰이더 단계의 몫**이다.
        
        따라서, 테셀레이터 단계를 **자료 처리 단계가 아니라, 자료 생성 단계**라고 부르는 것이다. 
        
    - 기본 도형의 생성 2개
        - 테셀레이터 단계 처리의 2번째는, **첫 부분에서 선택한 표본 위치**들을
        
        파이프라인 이후 단계들이 **렌더링 가능한 기하구조로 사용**하는 데 필요한
        
        **기본 도형 정보를 생성**하는 것이다.
        
        - **테셀레이션 시스템이 활성화**된 파이프 라인의 경우**, 입력 조립기**가 **기본도형 연결성 정보**를 만들어서, **덮개 셰이더 단계**에 넘겨주는 것은 맞는 말이다.
            
            **그러나**, 테셀레이션 단계들이 활성화된 경우, 입력 조립기가 산출한 입력 기본 도형은
            
            반드시 제어 패치 종류들 중 하나인데, **그 기본도형은 제어점으로서의 정점들의 연결성이 지정된 하나의 제어 패치**일 뿐, **그래도 레스터화 할 수 있는 형태의 실제 기본도형이** **아니다**. 
            
        - 
    - 기본도형 읽기
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%204.png)
        
    
    **3.6.4 테셀레이션 단계의 파이프라인 자료 흐름 출력 4개**
    
    - ~~
        
        테셀레이서 단계의 테셀레이션 공정이 한번 완료되면, 그 결과가 **SV_DomainLocation**이라는
        
        **시스템 값 의미소**를 통해서 **영역 셰이더 단계에 전달** 된다.
        
        각각의 **영역 “좌표점”마다 이 시스템 값 하나가 영역 셰이더 단계에 전달**된다.
        
        즉, **테셀레이터 단계의 출력 점 하나마다 영역 셰이더 프로그램이 한번씩**
        
        **실행**되는 것이다. **영역 셰이더에 주어지는 점은 단지 현재**
        
        **영역 안에서의 좌표**일 뿐이다.
        
        새롭게 테셀레이션된 기하구조에 대해 만들어진 **기본도형 위상구조 정보**는
        
        **영역 셰이더 단계가 사용하지 않는다.**
        
        개념적으로는, 그 정보는 영역 셰이더 단계를 건너뛰어서 **기하 셰이더** 
        
        단계에 직접 전달된다고 할 수 있다.
        
        기하 셰이더 단계는 완성된 기본도형들을 인식하므로, 이러한 정보를 활용할 수 있다.
        
        테셀레이션 단계에서는 **인접성 정보를 포함하는 기본도형 위상구조**를
        
        생성하지는 못한다는 점을 기억해야 한다.
        
        즉, 테셀레이션 단계들이 활성화된 경우, 기하 셰이더 단계는
        
        **인접 정보를 포함하는 기본도형** 종류를 받지 못한다.
        
        따라서 기하 셰이더 프로그램으로 구현할 수 있는 알고리즘이 제한되지만
        
        일반적으로 **인접성 정보가 필요한 계산이라면, 덮개 셰이더나**
        
        **영역 셰이더 프로그램에서도 수행**할 수 있다.
        
    
    **3.7 영역 셰이더 단계**
    
    - 개요 3
        - **덮개 셰이더 단계와 테셀레이터 단계로부터 모두 입력**을 받는다.
        - **정점들을 출력**하고, 그 출력 정점들은, **래스터화기 단계로 입력**된다.
        - **덮개 셰이더가 설정한 테셀레이션 알고리즘**을 **테셀레이터 단계가 생성한**
        
        **위치들에 적용**해서 **실질적인 테셀레이션 연산을 수행**하는 것이 
        
        바로 이 영역 셰이더 단계이다.
        
    
    **3.7.1 영역 셰이더 단계의 파이프라인 입력**
    
    - 개요
        - 영역 셰이더 단계는 **테셀레이터 단계가 생성한 좌표 점마다 한번씩 실행**
        - **덮개 셰이더 단계가 산출한 완성된 제어 패치도 입력**받아서 정점 생성에 사용한다.
        - **제어 패치의 제어점 개수**는, 제어 패치의 종류에 따라 1에서 32개로 다양한데,
        
        반드시, **덮개 셰이더 프로그램의 outputcontrolpoints 함수특 성에 지정된 개수와 일치**해야 한다.
        
    
    ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%205.png)
    
    - 첫번째 인자 특성 2개
        - 템플릿 스타일로 제어점들이 주어지는데, 첫 인수는
        
        제어점의 구조체 형식이고, 둘째 인수는 제어 패치의 제어점 개수이다.
        
        - 입력 제어 패치는 수정이 불가하므로, const 매개 변수
        
        영역 셰이더 프로그램은 입력 제어 패치에 읽기 전용으로만 접근할 수 있으므로
        
        제어 패치를 수정하거나 자료를 추가할 필요가 있다면, 반드시
        
        덮개 셰이더 프로그램에서 미리 처리해 두어야 한다.
        
    - 2번째 인자 특성 3개
        - **SV_DomainLocation** 에는 **테셀레이터 단계가 생성한 위치 좌표**가 들어 있다.
        - 이 특성의 구체적인 형식은**, 영역의 종류에 따라 다르다**
        
        ex_ isoline, quad의 경우는 float2, tri의 경우에는 float3 
        
        - 이 좌표는, 영역 셰이더 단계**의 현재 실행에서 정점 자료를 생성할 위치 (** 영역 안에서의 ) 를 나타낸다. 즉, 영역 셰이더 프로그램이 구현하는 함수에 의해 결정되는
            
            **가상의 표면에 대한 하나의 표본 추출 지점**을 정의한다.
            
        
    - 3번째
        - 덮개 셰이더 단계의 패치 상수 함수가 생성한 상수들을 담은 구조체도 받는다.
        
    - 영역 세이더 프로그램의 역할 정리 3가지
        - 영역 셰이더 프로그램의 매 실행마다 입력 제어 패치의 모든 자료가 주어진다.
        - 패치 상수 함수가 전달한 자료 역시 제어 패치의 모든 제어점에서 동일하다
        - 영역 셰이더 프로그램의 실행마다 변하는 입력은 영역 위치 좌표 뿐이다.
        
    
    3.7.3 영역 셰이더 처리 공정
    
    - 가장 중요한 역할
        
        정점의 위치 결정하기 
        
    - **제어 패치, 테셀레이터의 기하학적 의 의의**
        - 제어 패치라는 것은, **가상의 표면을 정의하는 일단의 매개변수들의 집합**이다.
        - 테셀레이터 단계가 **생성한 각 좌표는** 그 **가상 표면에서 ‘추출’하고자 하는 표본들의 위치**에 해당한다.
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%206.png)
        
        - 가상 표면은, 테셀레이터가 점들을 어디에 몇개나 생성했는지와는 무관하게 동일하다는 것이다.
        
    - 테셀레이션을 이용한 표면 렌더링 단계 5 ( 전반적인 테셀레이션 과정 )
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%207.png)
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%208.png)
        
    
    - **3.7.4 영역 셰이더 단계의 파이프라인 출력 3가지 특성**
        - 완성한 정점을 파이프라인의 다음 단계로 넘겨준다.
        
        이때 **출력 정점의 위치를 시스템 값 의미소 SV_Position에 기록**하는 것이 일반적이다.
        
        레스터화 공정을 위해 반드시 필요하다.
        
        - 기하 셰이더 단계가 **활성화된 경우,** **완성된 형태의 기본도형**들을
        
        기하 셰이더가 받아서 처리한다. 이 경우, 기본도형 정보는 
        
        **테셀레이터 단계에서 생성**된 것이다.
        
        - 활성화되지 않은 경우, **출력은 래스터화기 단계로 직접 전달**되는데 ,
        
        그 **단계 역시 처리의 단위는 기본도형**이다. 
        
- 그래픽 원리
    
    **( 오일러 )**
    
    - **key frame ?** , in_between_frame,  in_between_frame 그리는 방법
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%209.png)
        
        interpolation을 통해 중간 in - between frame을 그려주게 된다.
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2010.png)
        
        key frame 0 이 초기값이고
        
        key frame 이 1 지났을 때 변화된 결과를 얻어낼 수 있다. 
        
        ( 즉, 1초가 지났을 때 ) 
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2011.png)
        
        중심점은 p0 에서 p1으로 가게 될 것인데
        
        그 중간 과정에서의 중심점을
        
        linear interpolation으로 그려낼 수 있게 된다. 
        
        또한 각도도 0에서 90으로 가게 된다.
        
        이러한 각도 또한 선형 보간을 통해서
        
        중간 과정에서의 각도들도 구할 수 있게 될 것이다.
        
    
    **( 쿼터니언 )**
    
    - 삼각함수 덧셈 공식 ( 3가지 )
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2012.png)
        
    - 켤레와 곱
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2013.png)
        
    - 거리와 곱( 절대값 )
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2014.png)
        
    - 쿼터니언 회전 표현 공식
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2015.png)
        
    
- 시스템 프로그래밍
    
    ( 복습 ) 
    
    - **APC ( 비동기 함수 호출 매커니즘 )** Queue ? // 관련 함수
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2016.png)
        
        각 쓰레드는 독립적으로 APC Queue
        
        를 지니고 있다.
        
        여기에 들어간 것들은
        
        해당 쓰레드가 알림 가능한 상태로 들어갔을 때
        
        호출할 콜백 함수들을 모아놓은 것
        
        즉, 해당 쓰레드가 알람 가능한 상태가 되면
        
        이 큐 안에 있는 **모든 함수들이 실행**되는 것이다.
        
        그 다음 완전히 큐를 비워준다.
        
        ### WriteFileEX 의 함수 ?
        
        IO가 완료가 될 경우에
        
        ACP Queue에다가 콜백함수 정보를 입력한다.
        
    - Pseudo 핸들을 진짜 핸들로 만들어주는 경우 + 사용하는 함수 + 중요한 특징
        
        가짜 핸들을 진짜 핸들로 만들어줘야 하는 경우도 있다.
        
        어떤 경우가 그러할까 ?
        
        **A프로세스가 B 프로세스를 생성**
        
        **A는 자기 자신의 핸들을 B에 전달하고 싶다.**
        
        어떻게 ?
        
        핸들테이블을 상속시켜주면 된다.
        
        하지만, 자기 자신의 핸들 정보는 핸들테이블에 없으므로
        
        자기 자신의 핸들 정보는 전달할 수 없다. 
        
        **1) 등록 방법 : 어떻게 상속할 것인가**
        
        - A 프로세스 커널 오브젝트에 대한 핸들 정보를, 자기 자신의 핸들 테이블에 저장해야 한다
        - 이때 쓰는 것이
        
        ```cpp
        DuplicateHandle ( A 핸들 = 프로세스 핸들 정보 , ex)
        256 = 복사하고픈 핸들 정보, B 핸들  = B 프로세스 핸들 정보, 
        &val ) 
        ```
        
        A 프로세스에 등록된 핸들 정보 256 이라는 핸들을
        
        B 프로세스의 핸들 테이블에 복사를 해달라
        
        복사를 하면 256 이 아니라, 다른 값으로 복사가 될 수도 있다.
        
        왜 ? 256 이라는 숫자는 A 프로세스에게 고유한 것이다
        
        A 프로세스에게만 의미있는 숫자
        
        B 핸들 테이블에저장될 때는 다른 핸들 값으로 저장되어
        
        해당 핸들 값이 A 프로세스 커널 오브젝트를 가리키는 형태로 진행될 수도 있다.
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2017.png)
        
        아래의 경우 256이 364로 저장된 것
        
        위 인자에서 &val 은, 바뀐 값 364 라는 숫자가 들어가 있게 될 것이다.
        
        ---
        
        **2) 왜 상속하려고 하는가**
        
        - A 프로세스 커널 오브젝트 핸들값 → B 프로세스 커널 오브젝트 핸들값
        - 자식 프로세스 입장에서는 부모 프로세스가 종료되기를 기다릴 수 있다.
        - 핸들 정보만 있다면
    - Pseudo 핸들의 중복
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2018.png)
        
        자기 핸들 테이블에 핸들값 복사
        
        핸들값은 고유해야 하므로 중복되면 안된다.
        
        위와 같은 형태가 되고, Usage Count 는 2가 될 것이다.
        
        ---
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2019.png)
        
        자기 자신을 가리키는 핸들값을, 
        
        자신의 핸들 테이블에 저장해라
        
        가짜 핸들을 자기 핸들테이블에
        
        진짜 핸들값으로 변경하여 저장해랴
        
    - IPC 별 특성 3가지
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2020.png)
        
        통신범위 : 서로 다른 컴퓨터 상에 프로세스가 존재해도 통신이 가능 == 제한 없음 ! 왜 ?
        
        주소만 알면 되기 때문에
        
        이름이 없다 ?
        
        네트워크 상에 연결된 외부의 컴퓨터와는 연결되어 있지 않다.
        
    - 이름 있는 ⁷파이프 3가지 큰 범주
        
        ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2021.png)
        
        서버가 있고 클라이언트가 있다
        
        이름 있는파이프는 양방향 통신이 가능하다.
        
        서버 측에서 파이프를 만들어야 한다
        
        CreateNamedPipe : 파이프 생성
        
        그리고 생성한 파이프를 외부로 연결시켜야 한다
        
        ConnectNamedPipe
        
        이제 외부에 있는 프로세스
        
        클라이언트
        
        노출되어 있는 Pipe에 연결시도하는 녀석이 
        
        CreateFile 함수를 통해, 연결을 한다.
        
        ( 메일 슬록의 Sender가 메일함과 연결하기 위한 과정과 동일 )
        
        ---
        
    - 파이프 방식의 IPC ( 이어서 )
        - SetNamePipeHandleState + DWORD PipeMode
            - 각 Pipe 의 세부 옵션을 주는 함수
            - DWORD PipeMode
                - 기본적으로 메세지를 주고 받는 방식이 binary라고 가정해보자
                - 그런데 메세지 기반으로 읽고 싶을 수도 있다
                
                ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2022.png)
                
        - FlusFileBuffer + DisconnectNamedPipe + CloseHandle
            
            ![Untitled](1%2022%2047834ba38eb74d6cb1434758f6ee0325/Untitled%2023.png)
            
            **버퍼를 비우는 것**
            
            **Write Buffer를 비우는 것**
            
            Read Buffer는 그냥 내가 읽어내면 된다.
            
            CloseHandle 함수는 Usage Count를 감소시켜주는 함수일 뿐
            
            모든 Pipe 들을 닫아주는 함수가 아니다
            
            따라서 이전에 반드시 
            
            DisconnectNamedPipe  함수를 실행해야 한다.
            
    - 가상 메모리 관리
        - 페이지 상태 3가지
            
            Reserve는 Window Only
            
            Free, Commit
            
        - 메모리 할당의 시작점과 단위 ( 특정 단어 ) + 그 이유
            
            **특정 메모리 시작점**을 기준으로
            
            **1페이지 단위**로 할당 ( 최소 단위 )
            
            단, **Allocation Granularity Boundary** 기준으로
            
            메모리가 할당된다.
            
            **( 이유 = 메모리 단편화를 막기 위해서 )**
            
            이게 무슨 말이냐면, 
            
            4개의 페이지가 있다고 할때
            
            A,B,A,B 이렇게 따로 할당되는 것을 막기 위해서
            
            이러면 비효율적이니까
            
            미리 2개를 최소로 할당하는 것
            
            즉, 내가 특정 시작점을 기준으로 A를 한개만
            
            할당한다고 하더라도
            
            실제는 2개 크기 == **Allocation Granularity Boundary** 
            
            가 할당된다는 것이다
            
            예를 들어, 내가 4k byte를 할당하고 싶다고 한다면
            
            실제로는 64k byte가 할당되고
            
            또 다시 다른 종류의 메모리를 할당한다면
            
            나머지 60kbyte는 그대로 두고
            
            다른 영역에 또 다시 64k byte를 할당하고
            
            그 안에 할당할 메모리를 채워넣는 개념
            
            **미리 넉넉하게 메모리 공간을 확보해두는 개념이다.**