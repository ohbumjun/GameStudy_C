# 1.20

---

- 시스템 프로그래밍
    
    **( New )** 
    
    **1장. 시스템 프로그래밍 개요 ( 책 )**
    
    - 시스템의 범위
        
        하드웨어 + 운영체제 ( 시스템 ≠ 하드웨어 !!! 라는 것 —> 운영체제 까지 묶어야 한다 )
        
    - 컴퓨터 구조, 운영체제 구분
        
        ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled.png)
        
        - cpu, 캐쉬 : 컴퓨터 구조
        - 메인 메모리, 하드디스크 ( I/O 연산 ! ) : 운영체제
        
    - 컴퓨터 하드웨어 (전체) 구성 ( 그림 그려보기 )
        
        ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%201.png)
        
    - cpu 4가지 요소
        
        ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%202.png)
        
    - cpu 4가지 요소와 전반적인 프로세스
        
        ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%203.png)
        
        - A 라는 실행 파일 ( 2와 3을 더하는 덧셈 기능 )을 컴파일 하게 되면 ? —>
            
            ---
            
            A 라는 프로그램을 컴파일 —> **실행 파일은 하드디스크에 저장된다**
            
            그 실행 파일은 덧셈 기능을 한다고 해보자.
            
            2 + 5 를 하는 역할
            
            **컴파일된 바이너리 코드** 안에는
            
            덧셈이라는 명령어 , 2, 5 라는 숫자들이 존재
            
            모두 하드디스크에 하나의 실행파일로 존재
            
        - 해당 .exe 파일을 더블클릭하게 되면 ? ( 2 )
            
            더블클릭을 하면, 실행을 위해 **메인 메모리로 올라간다**
            
            **메인 메모리에 올라와 있는 것만 cpu 기반 연산이 가능하다.**
            
        - cpu로의 이동
            - 버스 인터페이스의 역할
                
                실제 연산이 이루어지기 위해서는
                
                해당 데이터가 cpu 쪽으로 전달되어야 한다.
                
                **입출력 버스를 타서**
                
                **버스 인터페이스로 들어간다.**
                
                **입출력 버스는 전기적 신호에 의해 데이터를 이동 시킨다.**
                
                **버스 인터페이스는, cpu 내부로 데이터 (ex. 명령어, 피연산자 )를 읽기 위해서 필요한 요소이다.**
                
                **입출력 버스는 나름의 통신 규약**이 존재하고
                
                그 규악에 따라서 데이터를 이동, 혹은 데이터를 주고 받는다
                
                입출력 버스의 규약을 이해하고 있어야만, 데이터를 주고 받을 수 있다는 의미이고
                
                **이 규약을 이해하고 있는 녀석이 바로 버스 인터페이스 인 것이다.**
                
            - 버스 인터페이스의 특성
                
                **버스 인터페이스는 입출력 버스에 맞물려 있는**
                
                **모든 녀석들이 가지고 있다.**
                
                예를 들어, 네트워크 카드는, 외부 데이터를 읽어 들이는 녀석이라고 해보자
                
                이 녀석을 하드디스크에 저장하려면
                
                입출력 버스를 통해 데이터를 이동시켜야 한다.
                
                그렇다면 마찬가지로 이 네트워크 카드 ( 뿐만 아니라, 모니터 및 키보드도 )
                
                또한 입출력 버스의 통신 규약을 이해하고 있어야 한다.
                
                **즉, 그 안에 버스 인터페이스가 내장되어 있다는 것이다.**
                
        - ALU 의 역할
            
            ALU는 실질적인 연산을 하는 녀석이다
            
            덧셈 , 2, 3, 이라는 데이터가 왔다면
            
            2,3 은 반드시 ALU로 전달되어야 한다. 실제 연산이 이루어져야 하니까
            
        - 컨트롤 유닛 역할
            
            **덧셈. 이라는 것은, 컨트롤 유닛.으로 가야한다.**
            
            즉, 덧셈이라는 명령어.는 컨트롤 유닛으로 간다.
            
            컨트롤 유닛은, **명령어를 해석**하는 것
            
            아 ! 덧셈하라는 것이구나! 야 ALU 더 덧셈해라 ! 라고 
            
            어떤 연산을 할지 알려주는 역할을 하는 것이다.
            
            즉, **일종의 Brain** 인 것이다.
            
            **cpu 가 해야할 일을 결정지어주는 것**이 바로
            
            컨트롤 유닛.인 것이다.
            
        - 레지스터 역할 —> 3개 설명
            
            **레지스터는 cpu 전용 저장장치이다.**
            
            명령어 왔다고 무작정 컨트롤 유닛에 넣고
            
            피연산자 왔다고 무조건 ALU 넣고
            
            이건 아니라는 것이다.
            
            각자가 하던 일이 있는데 무작정 다른 것을 넣어버리면
            
            문제가 생길 수 있기 때문이다.
            
            **따라서 ALU와 컨트롤 유닛이 필요할 때**
            
            **데이터를 레지스터로 부터 가져갈 수 있게 하자는 것이다.**
            
            **즉, 버스 인터페이스를 거쳐서 레지스터에**
            
            **데이터들이 저장되게 되는 것이다.**
            
        - 레지스터 ~ 컨트롤 유닛 관련성
            
            컨트롤 유닛이 뎃셈.이라는 명령어를 가져오고
            
            “덧셈”이라고 해석하게 되면
            
            ALU에게 덧셈해 ! 라는 신호를 주고
            
            레지스터의 2,3 이라는 데이터도 ALU에게 가져다 준다.
            
        - 4개 역할 정리
            
            ALU는 연산 담당
            
            컨트롤 유닛은 cpu의 행동을 결정
            
            버스 인터페이스는 입,출력 버스가 데이터를 어떻게 주고 받는지 알고 있는 녀석
            
            들어오는 데이터는 레지스터에 저장이 된다.
            
    - 클럭 신호
        - 클럭 신호의 정의 및 역할
            
            컴퓨터의 모든 장치에는
            
            클럭신호 라는 것이 들어간다
            
            ex) cpu, 메인 메모리 ...등등
            
            **클럭 신호란, 클럭 발생기의 클럭.이다.**
            
            그래서 **모든 장치에게 일정 간격 신호를 준다.**
            
            **그 신호에 맞춰서 모든 장치가 연산**을 한다.
            
            이를 통해 동작 타이밍을 결정한다.
            
        - 클럭과 성능의 관계
            
            클럭을 높이면 시스템 성능은 좋아진다
            
            클럭이 발생할 때에 연산 혹은 작업이 이루어지기 때문이다.
            
            하지만 클럭이 발생할 때마다 열도 발생한다.
            
            열이 높아지면 시스템이 불안해진다.
            
            따라서, 정도 이상 클럭을 높일 수 없다.
            
        - 클럭의 목적
            
            ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%204.png)
            
            그렇다면, 이러한 클럭은 왜 필요한 것일까 ?
            
            **요소들의 동기화를 위해서 !**
            
            ( 데이터 분실을 막기 위해서 → 아래 참고 )
            
            덧셈 연산을 하는 연산 장치가 있다고 가정해보자.
            
            덧셈 결과를 버퍼 ( 메모리 라고 하자) 에 저장하고
            
            출력 장치는 그 값을 가져다가 출력해준다 ex) 모니터에 출력
            
            연산 장치는 초당 10번 클럭을 발생시켜서 작업, 출력 장치는 초당 5번 작업을 한다고 해보자.
            
            그러면 출력 장치가 가져다가 출력도 하기 전에
            
            Buffer, 메모리에 있는 데이터를 덮어 쓰게 되는 문제가 발생할 수 있다.
            
            **따라서 동일한 클럭수를 주자는 것이다.**
            
            **중아에서 클럭 신호를 일률적으로 전송을 해주는 것이다.**
            
            보통 연산 장치 중에서 가장 min 값으로 지정을 해준다
            
            ex) 위의 경우 5번의 클럭
            
            5번의 클럭에다가 10번의 클럭을 해주면 타겠지.. ?
            
    
    ---
    
    **2장.** 
    
    - 아스키코드 vs 유니코드
        - 문자셋의 3가지 종류와 특성
            
            ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%205.png)
            
            멀티바이트 : 표현해야 하는 문자에 따라서, 바이트의 크기가 결정되는 것.
            
        - 문제
            
            **Multi Byte Character Set**
            
            ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%206.png)
            
            - **정답 + 이유**
                
                ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%207.png)
                
                sizeof : 할당된 메모리 공간의 크기를 얻고자 하는 것
                
                strlen : 문자열의 길이
                
                왜 8 이 나오는 것일까 ?
                
                영어 1byte * 3 + 한글 2byte * 2 + 끝에 null 1byte
                
                왜 문자열 길이는 7이 나올까 ?
                
                5가 나와야 하는 것이 아닐까 ?
                
                한글이 2글자가 들어가니까. 즉, 각각 문자열 길이 2씩 인식이 되는 것이다.
                
                **이 부분이 바로 MBCS 에서 한글을 사용할 때**
                
                **문제가 될 수 있는 부분인 것이다.** 
                
- 수학
    - 1 라디안 의미, 각도
        
        
        호의 길이가 반지름과 같게 되는 만큼의 각을 1 라디안 ( 1 radian ) 이라고 한다.
        
        1 라디안은 실제 약 57.3도 이다.
        
    - degree와 라디안 관계
        
        1 라디안 *  파이 = 180도
        
        라디안 = 57.3
        
        파이 =3.14 —> good 1
        
    - 벡터의 내적 ( 보기 )
        
        ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%208.png)
        
        대수적 정의, 기하학적 정의
        
        - 답
            
            ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%209.png)
            
        
    - 벡터의 내적을 이용한 각도 공식
        
        ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%2010.png)
        
    
    **float Vector3::Angle(const Vector3& v) const**
    
    - 위의 식 : 두 벡터3 간의 각도구하기 —> 코드작성
        
        ```cpp
        float Vector3::Angle(const Vector3& v) const
        {
        	Vector3 v1 = *this;
        	Vector3 v2 = v;
        
        	v1.Normalize();
        	v2.Normalize();
        
        	float DotResult = v1.Dot(v2);
        
        	Angle = RadianToDegree(acosf(DotResult ));
        
        	return Angle;
        }
        ```
        
- DX
    - **문제**
        
        **XMLoadFloat2 의 의미**
        
        **XMStoreFloat2 의 의미**
        
        - 답변
            
            ```cpp
            // XMFLOAT2를 XMVECTOR에 적재
            XMVECTOR XM_CALLCONV XMLoadFloat2(const XMFLOAT2* pSource);
            
            // XMVECTOR를 XMFLOAT2로 저장
            void XM_CALLCONV XMStoreFloat2(XMFLOAT2* pDestination, FXMVECTOR V);
            ```
            
    - GetCursorPos, ScreenToClient 의 기능
        
        **GetCursorPos 함수**는 Screen에서의 마우스 좌표를 조사한다.
        
        윈도우 스크린 전체를 대상으로 한다.
        
        즉, 모니터 전체를 하나의 좌표계로 생각하는 것
        
        다시 말하면, 현재 프로그램의 대상이 되는 
        
        윈도우 창에서만의 좌표계에 대응되지 않는다는 것이다.
        
        윈도우 창의 0,0
        
        즉, 시작점에 마우스를 위치시키더라도 창이 화면의 가운데에 있다면
        
        0,0을 반환하지 않는다.
        
        따라서 **Screen To Client** 함수를 통해
        
        현재 윈도우창의 위치 ( 좌상단 시작점 기준, 아래로, 옆으로 y,x 증가 )
        
        를 기준으로 좌표값을 얻ㅇ오는 함수이다.
        
        [**http://egloos.zum.com/EireneHue/v/967113**](http://egloos.zum.com/EireneHue/v/967113)
        
- C++
    
    ( C 파트 )
    
    **모두의 코드**
    
    **16-3 : 구조체와 친구들 ( 공용체 + enum )**
    
    - 16진수, 8진수 출력 타입
        
        %x, %o
        
    - 공용체 개념 + 특성
        
        
        ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%2011.png)
        
        구조체와 달리, **메모리를 공유**한다.
        
        즉, 공용체의 **각 멤버들끼리, 메모리 시작 주소가 모두 동일**한 것이다.
        
        **( 특성 )**
        
        union A의 경우
        
        j 값을 변경하면 i 값을 변경할 수도 있고
        
        i 값을 변경하면, j 값도 변경할 수 있다.
        
    - 문제
        
        ```cpp
        /* 공용체 */
        #include <stdio.h>
        union A {
          int i;
          char j;
        };
        int main() {
          union A a;
          a.i = 0x12345678;
          printf("%x", a.j);
          return 0;
        }
        ```
        
        - 실행 결과 + 이유
            
            78
            
            왜 78일까 ?
            
            0x12가 나와야 하는 것 아닌가 ?
            
            바로 빅앤디안, 리틀 앤디안 문제가 존재하기 때문이다.
            
    - 빅앤디안, 리틀앤디안 정의 차이
        
        컴퓨터에서 메모리에 수를 저장할 때, 
        
        **우리가 생각하는 방식대로** 
        
        **낮은 주소값에, 상위 비트( 비트는 왼쪽으로 가면 상위 ) 를 적는 방식을 빅앤디안 방식.**
        
        **우리가 생각하는 방법의 정반대로 낮은 주소값에**
        
        하위 **비트를 적는 방식을 리틀 앤디안.이라고 한다.**
        
        ```cpp
        /* 공용체 */
        #include <stdio.h>
        union A {
          int i;
          char j;
        };
        int main() {
          union A a;
          a.i = 0x12345678;
          printf("%x", a.j);
          return 0;
        }
        ```
        
        - 빅앤디안 출력 결과 및 설명
            
            ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%2012.png)
            
        - 리틀앤디안 출력결과 및 설명
            
            ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%2013.png)
            
        - 공통되는 중요한 핵심 특성
            
            ![Untitled](1%2020%20ef3dd5f48d5f4bfe8e961cebe5033977/Untitled%2014.png)
            
            **바로 1 바이트를 기준으로 배치**된다는 것이다 !
            
            우리의 경우,
            
            int i —> 4byte를 123456 으로 해서 저장하려고 했다면
            
            1byte 기준으로 나누면 12, 34, 56, 78 이 되고
            
            이것을 **높은 주소값부터  ( 오른쪽으로 갈수록 높은 주소값 )** 
            
            **상위 비트 ( 우리가 생각하는 왼쪽 숫자로 갈수록 상위 비트 )**를 적는 방식이 바로 리틀 앤디안 인 것이다.
            
        
    - 문제 2
        
        ```cpp
        #include <stdio.h>
        union A {
          int i;
          **short j;**
        };
        int main() {
          union A a;
          a.i = 0x12345678;
          printf("%x", a.j); **// j형에 short를 지정하고 출력하기**
        	printf("%x", a.i); **// i도 출력하기**
          return 0;
        }
        ```
        
        - 정답 + 이유
            
            ```cpp
            0x5678
            
            0x12345678
            ```
            
            short는 2바이트, 따라서 j는 2바이트를 차지한다.
            
            j와 i가 위와 같이 출력되는 이유는
            
            컴퓨터는 자신이 메모리에 ‘수’를 
            
            ‘리틀 앤디안 방식’ 으로 저장하고 있다는 사실을 알고 있기 때문이다.
            
            따라서 출력시 적절한 변환을 취해서 0x12345678을 출력하는 것이다.
            
            j 역시 현재는 ( 78 56 ) 부분을 가리키고 있지만
            
            컴퓨터는 j가 리틀 앤디안 형식으로 이루어졌다는 것을 알기 때문에
            
            j를 출력할 때에는 적절히 변환하여 0x5678을
            
            출력하게 될 것이다.