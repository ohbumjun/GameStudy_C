# 1.21

---

- **물리**
    - 속도와 속력의 차이
        
        ```cpp
        속력 : 단위 시간 당 이동한 거리 ( 이동거리 / 걸린 시간 )
        
        속력은 스칼라값이기 때문에, 방향을 나타낼 수 없다.
        
        반면, 속도는 ?
        속도 = ( 변위 / 걸린 시간 ) --> 변위 : 중간의 이동거리, 방향 생각 x, 그저 출발점과 도착점의 직선거리와 방향
        
        방향을 포함 -> 벡터값.
        
        정리하자면,
        속력은 단위 시간동안 이동한 거리
        속도는 단위 시간당 출발점과의 거리와 방향
        ```
        
    - **포물선 운동**
        
        가로, 세로 방향 이동 방식 + 공식 ? 
        
        - 답변
            
            ```cpp
            포물선 운동
            	- 수평 방향으로는, 물체에 작용하는 힘이 0이므로, 등속도 운동
            	- 수직 방향으로는, 물체에 중력이 작용하므로, 등가속도 운동
            	둘을 합친 것
            
            	처음 순간 위치를 0 이라고 했을 때,
            	시간 t 동안 물체가 수평 방향으로 이동한 거리 x => 수평방향 속도 * 시간 ( t )
            	시간 t 동안 물체가 수평 방향으로 이동한 거리 y => 1/2 * 가속도 * 시간^2
            ```
            
- 계산 셰이더
    - cpu와 gpu의 차이 ( 3개 설명 )
        - cpu와 gpu의 큰 차이는
        
        **코어의 개**수이다.
        
        - **cpu 보다 gpu에**
        
        **ALU 개수가 훨씬 많다.**
        
        훨씬 더 코어가 많다
        
        즉**. 단순 계산에 더 최적화** 되어 있는 녀석이다.
        
        - 그런데 코어 하나하나를 살펴보면
        
        cpu 코어가 더 똑똑하다
        
        마치 1당 100의 용사
        
        범용적인 용도로 사용되는 녀석들.
        
        gpu는 성능은 떨어지지만 개수로 밀어붙이는 녀석
        
    - 계산 셰이더 원리
        
        **gpu에게 범용적인 용도를 맡기는 것**이 바로 
        
        계산 셰이더이다.
        
        cpu가 일반적인 연산들을 처리하듯이
        
        gpu 에게도 렌더링 외에
        
        일반적인 연산을 맡기겠다는 의미이다.
        
    - 병렬 처리 개념
        
        일감들이 매우 많은데
        
        그 일감들이 병렬처리가 가능할때
        
        gpu에게 맡기는 경우가 된다.
        
        병렬처리가 된다는 의미는 ?
        
        일감들이라는 것이 만약에
        
        이전 일감의 연산 결과에 연산을 하고
        
        또 그 결과를 가져다가 이후의 일감이 연산을 하고
        
        이런식으로 모든 연산간에 엮어 있다면
        
        병렬적으로 처리하기란 매우 어려운 문제일 것이다.
        
        반면, 모든 일감들이 서로
        
        **독립적으로 실행될 수 있는 경우도**
        
        **존재할 것이다.**
        
        ex) 소수를 찾는 문제
        
        아주 큰 숫자 1조에 대해서
        
        찾기 위해서는 한딴한땀 다 구해서 비교해야 한다
        
        그 외 방법은 현재까지 없다.
        
        1에서 1000 사이의 소수들을 구해야 하는 상황이라고 해보자.
        
        이것들 gpu에게 넘긴다면
        
        1,2,3,4,5 가 소수인지 각각 판별하는 것은,
        
        1,2,3,4,5 서로 끼리에 대해서
        
        서로가 소수이던 말던 상관이 없다.
        
        자기가 소수인지만 조사하면 되기 때문이다.
        
        **따라서 각각의 연산을**
        
        **독립적으로 실행할 수 있을 것이다.**
        
        1 ~ 100, 101 ~ 200, .... 900 ~ 999 까지
        
        10개로 쪼개서 gpu에게 넘겨서
        
        **각각의 GPU ALU에게 연산을 맡기면**
        
        **병렬적으로 처리할 수 있게 될 것이다.**
        
    - 계산 셰이더 원리를 굳이 적용하는 이유
        
        cpu와 gpu 사이에 데이터를 주고 받는 과정은 매우 느리다
        
        cpu ~  램
        
        gpu ~ 비디오램
        
        사이에는 매우 빠르지만..
        
        따라서 cpu가 계산하고, 그 결과를 gpu에 넘겨주고
        
        하는 이러한 과정은 부담스러운 작업일 것이다.
        
        따라서 gpu 내에서 알아서 잘 처리하게끔
        
        세팅해주려고 하는 것이다. 
        
- DX
    
    **( 복습 )**
    
    **3.1.3 공통 셰이더 코어**
    
    - 동작 과정 3
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled.png)
        
        - 셰이더 단계의 경우, 입력된 자료가 셰**이더 코어 안에서 처리된 후 그 결과가 바깥으로** **출력** 된다.
        - 셰이더 단계 안에서, 실행되는 **셰이더 프로그램**은 **특정한 목적을 위해** **hlsl 로 작성한 하나의 함수**이다. 셰이더 단계 안에서 **자료가 처리되는 동안 셰이더 프로그램**은 응용 프로그램이 그 단계에 **연결시킨 상수 버퍼, 표본 추출기, 셰이더 자원뷰 들에 접근**한다.
        - **셰이더 프로그램**이 주어진 자료를 다 처리하고 나면, 셰이더 단계는 그 결과를
        
        단계 밖으로 배출하고, 다음 번 입력 자료를 받아서 같은 과정을 반복한다. 
        
    - **셰이더 코어** 아키텍쳐 3
        - 셰이더 프로그램은, **hlsl 로 작성된 소스 코드**를 **gpu에 있는 특화된**
            
            **셰이더 처리기 코어**들에 맞게 설계된, **벡터 레지스터 기반 어셈블리 언어**로 **컴파일한 결과물**이다.
            
        - 이 어셈블리 언어는 컴파일러가 hlsl 프로그램을 어셈블리 언어로 변환하는 데 사용할 수 있는 **특정한 레지스터들의 집합을 정의**한다.
        - 이 레지스터들은 대부분 성분이 4개인 벡터 레지스터인데, 개별 성분을 스칼라 레지스터로 사용하는 것도 가능하다 .
            
            ex) 셰이더 코어가 입력 자료를 받는데 쓰이는 레지스터들도 있고, 계산을 수행하기 위한 임시 레지스터들도 있고, 출력을 위한 레지스터들도 있다.
            
        
    - **셰이더 코어** 아키텍쳐 동작 과정 5개 프로세스
        - 셰이더 코어에 대한 입력은 **v# 레지스터들**에 담겨서 전달된다.
        
        단계에 입력을 제공하는 것이므로, 이 레지스터들은 읽기 전용
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%201.png)
        
        - 셰이더 프로그램은, 이 레지스터에 담긴 입력 자료를 읽어서 수정하거나 다른 자료와 결합한다.
        
        이러한 중간 계산 과정에서 자료를 r# 레지스터들과 x#[n] 레지스터들에 저장할 수 있다.
        
        이런 레지스터들을 임시 레지스터.라고 한다. 중간값들을 담는 것으로 읽기와 쓰기가 모두 가능하다
        
        - 또한 셰이더 프로그램은 텍스처 레지스터 ( t# )와 상수 버퍼 레지스터 ( cb#[n] ),
        
        즉석 상수 버퍼 레지스터 ( icb[index] ), 순서없는 접근 레지스터 ( u# ) 들도 자료원으로 사용한다.
        
        - 이 레지스터들은, 여러 장치 메모리 자원들에 대한 접근을 제공하는 것이며, 순서 없는
        
        접근 레지스터를 제외하고 모두 읽기 전용이다.
        
        - 마지막으로 계산된 값들을 출력 레지스터 ( o# )에 기록하면, 그 값들이 파이프라인 단계로 전달된다. 셰이더 프로그램의 실행이 끝나면, 이 출력 레지스터들에 담긴 값들이 다음 단계의 입력 레지스터들ㄹ로 전달되고, 이 과정이 반복되는 원리이다.
        
    
    **3.3 입력 조립기 단계**
    
    - 1번째 자료 ( 정점 버퍼) 의 용도 및 용법 7개
        
        **정점 버퍼의 용도 및 용법**
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%202.png)
        
        - 입력 조립기의 임무는 정점들을 정확하게 조립하는 것이므로,
        
        응용 프로그램이 제공한, **정점 자료에 접근**해야 한다. 
        
        - 정점 자료는 **하나 이상의 정점 버퍼 자원들에** 들어 있고, 그 버퍼들의 구성과 자료 배치 방식은 다양하다 ex) 인스턴싱 구성, 다중 구성
        - 입력 조립기에는 **여러 개의 입력 슬롯이 있고, 각 슬롯마다, 하나의 정점 버퍼 자원**을 채워넣을 수 있다.
        - 각 슬롯에 채워넣는 **정점 버퍼 자원은 정점을 구성한느 여러 종류의 특성 들 중 하나 혹**은 여러 개를 담는다
        
        ex) 한 버퍼에는 위치 정보, 다른 버퍼에는 법선 벡터 자료
        
        ex) 모든 정점 자료를 하나의 정점 버퍼에 구조체들의 배열 형태로 담는 것도 가능하다
        
        - **응용 프로그램이 설정 가능한 입력 슬롯은 16개**이다.
        - 정점 특성들을 개별적인 버퍼에 담으면 특정한 렌더링 연산에 어떤 정점
        
        성분들이 필요한지를 동적으로 결정하는 것이 가능하다. 
        
        - 이를 통해, 정점 자료를 읽는 데 필요한 대역폭을 절감할 여지가 생긴다.
    
    ---
    
    **( New )** 
    
    정말 쉽게 말하면, 테셀레이션 단계는 물체를 만드는데 사용되는
    
    면의 개수를 늘리는 것이다.
    
    물체를 더 잘게 쪼개는 것이다.
    
    **3.6 테셀레이션 단계**
    
    - 개요 4개 ( 역할, 덮개 셰이더 프로그램의 영향, **하는 일 x**, 영역 셰이더와의 상호 작용 ) **4개**
        
        테셀레이터 단계의 임무는, **덮개 셰이더 단계의 패치 상수 함수**가 지정한
        
        **테셀레이션 계수들에 해당하는 만큼의 테셀레이션**을 수행해서
        
        **현재 영역 (domain) 안에서, 일단의 좌표점들을 생성**하는 것이다.
        
        ex) 사각형, 삼각형
        
        구체적으로 어떤 영역을 사용할 것인지는 **덮개 셰이더 프로그램의 domain**
        
        함수 특성으로 지정한다.
        
        **테셀레이터 단계가 수행하는 작업에**
        
        **제어 패치나 제어점들이 쓰이지 않는다.**
        
        그저, 정점들이 주어진 영역 안의 **어느 위치에서 만들어져야 하는지**를
        
        지시하는 **일단의 점들을 생성**할 뿐이다.
        
        이 점들이 영역 셰이더 단계로 전달되고, 영역 셰이더는 그 점들과
        
        덮개 셰이더 프로그램이 생성한 제어점들을 결합해서
        
        **그 점들에 물리적인 의미를 부여한다.**
        
    
    **3.6.1 테셀레이터 단계의 파이프라인 입력**
    
    - 정점 셰이더, 덮개 셰이더 입력의 비교
        
        **정점 셰이더**는 **입력 조립기 단계가 조립한 정점 ( 제어점 )** 들을 받아서 **출력 제어점** 생성
        
        **덮개 셰이더** 는 그 **제어점들로부터 만들어진 제어 패치**들을 받는다 
        
        ( **입력 조립기의 기본 도형 정보**와 함께 ) 
        
    - 테셀레이터 단계 입력 특성 3
        
        덮개 셰이더 단계의 **패치 상수 함수**가, **“계산”**을 통해서 만들어 낸
        
        **테셀레이션 계수들**.
        
        이 계수들은, **영역 객체의 각 부분을 얼마나 잘게 쪼갤 것인가**를 나타내는
        
        부동소수점 값이다.
        
        만일 **두 제어 패치에 대해 계산된 두 테셀레이션 계수 집합이 동일**하다면, 
        
        테셀레이터 단계의 관점에서, **그 두 제어 패치는 동일**한 것이다.
        
        즉, 테셀레이터 단계는 **두 입력을 구분하지 못하고,**
        
        **두 경우 모두 정확히 동일한 출력**을 낸다.
        
    
    ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%203.png)
    
    **3.6.2 테셀레이터 단계 상태 구성**
    
    - 특성
        
        테셀레이터 단계는 **응용 프로그램이 직접 구성하지 못하며 ,** 
        
        대신 덮개 셰이더 프로그램의 **“함수 특성” 을 통해서 구성한다.**
        
    - domain 4개
        - **영역 지정**
        - 테셀레이터 단계는 **제어 패치들을 분할 하는 것이 아니라**, **“영역” 을 분할 하는 것**이다.
        - 해당 함수 특성에 지정할 수 있는 값은 **3개 ( isoline, tri, quad )**
        
        즉, 테셀레이터 단계는 이 **함수 특성에 해당하는 영역 안의 점들을 결정**하고
        
        **영역 셰이더 단계에서 그 점들을 실제의 정점들로 “실현”**한다.
        
        - **생략할 수 없다.** 영역의 종류는 **패치 상수 함수가 계산한 테셀레이션 계수들의 개수가**
        
        **유효한지를 점검하는 데에도 쓰이기 때문이다.**  
        
    - partitioning 3개
        - **분할 방식 지정**
        - **integer, fractional_even, fractianal_odd, pow2 로 총4개**
        
        각 값은, 영역을 분할하는 서로 다른 방식을 나타낸다.
        
        - **분할 방식이 다르면, 생성되는 테셀레이션 점들도 크게 달라진다.**
    - outputtopology 2개
        - **출력 위상 구조 지정**
        
        즉, **지정된 영역**을 **지정된 분할 방식으로 분할**해서, **테셀레이션 점들을 생성**한 후에는, 그 점들로 기본도형 들을 형성해야 한다. **형성할 기본도형의 종류를 지정**하는 것이다. 
        
        - **triangle_cw, triangle_ccw, line** 총 3개의 값들이 존재한다.
    - maxtessfactor 3개
        - **최대 테셀레이션 계수**를지정한다.
        - **생략 가능**하다**. 자료 증폭의 최대 한계에 대한 “힌트”를 구동기에게 제시하는 역할**을 한다.
        - **구동기는, 테셀레이션 작업의 결과를 담기에 충분한 메모리를 효율적으로**
        
        **미리 할당**할 때, 이 특성으로 주어진 최댓값을 이용한다.
        
    
    **3.6.3 테셀레이터 단계 처리 공정** 
    
    - **요약** ( 그래서, 테셀레이터 단계가 수행하는 연산이 정확하게 무엇이냐 )
        - 테셀레이터 단계는 **주어진 영역 안에서 일련의 점들을 선택**하고,
        
        그 점들을 이용해서 **기본도형들을 생성**하고
        
        **그 기본도형들을 파이프라인 다음 단계에 넘겨준다**.
        
    
- 그래픽 원리
    
    **( New )**
    
    - 삼각 함수
        - 사분면에서의 Sin, Cos 양,음수 여부
            
            얼,싸,안,코
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%204.png)
            
            즉, 꼭 안외우더라도
            
            쎄타라는 각도가 어떤식으로 위치하느냐에 따라
            
            cos, sin의 위치도 구할 수 있을 것이다. 
            
        - 라디안 ?
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%205.png)
            
            **호의 길이가 1이 되는 선분**을 만들었을 때, 
            
            그 상황에 대한 각도를 1 라디안.이라고 표현한다.
            
        - cos ( -각도 ), sin ( -각도 ) 의 표현 결과
            
            cos( 쎄타 ) == cos ( — 쎄타 )
            
            sin (—쎄타 ) == — sint( 쎄타 )
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%206.png)
            
            x 축 을 기준으로 대칭 시켜도 ( 즉, 쎄타를 - 쎄타로 바꿔주더라도 )
            
            cos값은 동일하지만
            
            sin 값은 음수가 붙는 것을 확인할 수 있다.
            
    - 좌표계 변환 행렬
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%207.png)
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%208.png)
        
        사실 위 행렬은, 한 좌표계에서 다른 좌표계로 이동시키는 행렬이라고 생각하면 편하다.
        
    - Local → World
        - 문제
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%209.png)
            
            - 위 과정을 수행하기 위해 **곱해줘야 하는 행렬** ? + 그 결과 해석
                
                ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2010.png)
                
                **W의 행들은**, World Space 기준의 Local Space **좌표축들과 원점**에 해당한다. 
                
                ( 4번째 : World 상에서의 Position이라고 생각해도 된다 )
                
                위의 W 라는 행렬을 특정 ( 위치 벡터 혹은, 방향 벡터) 에 곱해주면
                
                1번째, 2번째, 3번째 행을 basis 로 하고
                
                ( 위치 벡터의 경우, 10,0,10 ) 이 되는
                
                새로운 변환된 ( 위치 or 방향 ) 벡터로 정의된다는 것이다. 
                
                ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2011.png)
                
    - World → Camera Space
        
        **( 사실상, Local → World를 반대로 적용한 것이라고 생각하면 편하다 )**
        
        - 위 변환의 의미 1번째 관점
            
            카메라의 좌표를 0,0,0 ( 원점 )으로 두고
            
            카메라가 바라보는 z 축을 방향으로
            
            모든 좌표 변환을 해야한다.
            
            즉, 카메라의 기저 벡터들을 중심으로 
            
            즉, right, up, look ( z 축 ) 벡터를 기준으로
            
            다시 좌표 변환을 해야 한다는 의미이다. 
            
            즉, World 좌표를 다시
            
            카메라의 Local 좌표로 바꿔주는 개념인 것이다.
            
            모든 물체를 카메라의 Local 좌표 개념으로 
            
            생각하겠다는 의미이다.
            
            **그러면 카메라의 Local 에서**
            
            **World 위치로 변환해주기 위해 곱해준 행렬이 있는데**
            
            **이 행렬의 역행렬들을 곱해주면 된다는 의미이다.**
            
            **즉, 역행렬 곱해주자 !**
            
            카메라의 World 행렬을 구한 다음에
            
            그것의 역행렬을 곱해주자.
            
        - 위 변환의 의미 2번째 관점
            
            
            카메라가 오른쪽 회전하면
            
            실제 화면상에서 물체는 카메라 위치를 중심으로
            
            왼쪽으로 공전한 형태를 띈다.
            
            카메라가 왼쪽으로 이동하면
            
            물체는 오른쪽으로 이동한 형태를 띈다.
            
            즉, 카메라가 World 공간 상으로 이동한
            
            방식
            
            그 반대로 각각의 물체들을 
            
            변환시키면 된다.
            
            따라서 
            
            카메라를 World Space 로 옮겨주기 위해
            
            S,R,T 행렬을 곱해서 만든 변환이 있다고 할때
            
            S는 어차피 1배이므로 무의미하고
            
            RT를 그 반대로 적용하면 된다는 것이다
            
            즉, 
            
            **1) 카메라를 30도 회전한다음,** 
            
            **2) 30도를 옮겼다면**
            
            이제 물체를 카메라 Local Space 로 변환을 해줄 때는
            
            **1) -30도를 옮기고,** 
            
            **2) -30도 회전을 시키자는 것이다**
            
        - 문제
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2012.png)
            
            - 답변
                
                **( 세계 공간을 기준으로 한 국소 공간의 ) 가 중요한 표현**
                
                ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2013.png)
                
                **이것은  World 공간 → Camera Space 가 아니라**
                
                **그 반대이다.**
                
                **즉, View 변환 행렬이 아니라는 의미이다.**
                
                **우리가 구해야 하는 것은 결과적으로**
                
                **W의 역행렬이다.**
                
            - 위 답변 행렬을 S,R,T 로 표현하면 ?
                
                ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2014.png)
                
            - S,R,T 로 표현한 결과물을 중심으로 역행렬을 구하면 ? ( 과정 )
                
                ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2015.png)
                
                여기서 R의 역행렬의 경우
                
                R 자체가 직교 행렬
                
                즉, 축 간에 모두 직교
                
                그리고 직교 행렬의 역행렬은
                
                전치 행렬과 동일하다.
                
                그래서 R의 역행렬은
                
                그 열 들이, 각 축으로 구성된 형태를 띄게 되는 것이다. 
                
    - Projection 변환
        - 의미
            
            **투영 변환**(projection transformation)은 n > m 이라 할 때 n 차원 공간의 점을 m 차원 공간의 점으로 바꾸어주는 **변환**을 말한다. 3차원의 한 점 p(x, y, z) 를 2차원의 한 점 p'(x, y) 로 **변환**하는 것을 예로 들 수 있다.
            
        - 2가지 종류
            - 원근 투영
            - 직교 투영
        - ( 키워드 ) 비율
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2016.png)
            
        - ( 키워드 ) 스크린 비율 고려
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2017.png)
            
        - ( 키워드 ) 카메라 앵글 고려
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2018.png)
            
        - ( 키워드 ) 행렬 변환
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2019.png)
            
        - ( 키워드 ) 깊이값 보존
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2020.png)
            
        - ( 키워드 ) 최종 형태 행렬
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2021.png)
            
    - Screen 변환 ( 원리 )
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2022.png)
        
- 시스템 프로그래밍
    
    **( 1장 보충 )**
    
    - 전처리기의 역할 ?
        
        #으로 시작하는 지시자의 지시에 따라
        
        소스코드를 적절히 변경하는 작업
        
    - 어셈블리 코드 ?
        
        cpu 에게 일을 시키는 명령어를 조합해서
        
        만들어진 프로그램 코드
        
        즉, cpu 명령어로 구성된 프로그램 코드
        
    - 바이너리 코드 ?
        
        1과 0으로만 구성되는 코드
        
        우리가 흔히 기계어로 번역한다라는 의미는
        
        컴퓨터가 이해할 수 있는 1과 0으로 바꿔준다는 것
        
    
    **( 2장 )**
    
    - WBCS ?
        
        유니코드.가 아니라
        
        유니코드 기반 프로그래밍. !
        
    - strlen과 null
        
        strlen은 문자열의 길이를 계산함에 있어서 NULL 문자를 포함하지 않는다.
        
    - 문제 1
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2023.png)
        
        - 출력 결과
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2024.png)
            
        - 이유
            
            문자열 길이는 5. 누가봐도 !
            
            하지만 fputc 함수를 10번 호출해야 정상결과가 나온다.
            
            **왜냐하면, 문자열 길이는 5이지만, 문자열에 할당된 크기가**
            
            **10바이트인 관계로 1바이트 데이터를 출력하는**
            
            fpuct 함수를 10번 호출해야 하는 것이다.
            
        - WCBS가 해결책이 되는 이유
            
            모든 문자들을 2바이트로 동일하게 처리하기 때문이다.
            
    
    **( WBCS )**
    
    - wchar_t ? 특징 + typedef로는 ?
        
        char 이 아니라 wchar_t를 톨해 자료형 char를 표현한다.
        
        char 변수는 1바이트 메모리 공간 할당
        
        wchar_t는 2바이트 메모리 공간 할당
        
        typedef unsigned short wchar_t
        
    - “ABC” 대신 L”ABC” ( 보기 )
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2025.png)
        
        - 위 코드가 문제가 되는 이유 + 해결책 + 총 차지하는 메모리 바이트
            
            배열 str은 **유니코드 문자열**을 저장할 준비가 되어 있지만
            
            대입 연산자 오른쪽은 여전히 **MBCS 기반 문자열**이기 때문이다.
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2026.png)
            
            **L은 문자열을 유니코드 기반.으로 표현하라**. 라는 의미를 지닌다.
            
            ABC 문자는 널 문자를 포함해서 총 8바이트
            
            유니코드에서는 문자열의 끝을 의미하는 널 문자도 2바이트로 처리한다.
            
    - 문제 2
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2027.png)
        
        - 호출결과 + 이유
            
            **컴파일에러** 
            
            strlen 은 SBCS ( 아스키 코드 기반 )문자열을 처리하기 위한 함수이다.
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2028.png)
            
            전달인자는 위와 같이 char* 형태여야 하는데
            
            L”ABC”는 *wchar_t 형태이기 때문이다.
            
            따라서, wcslen 함수를 통해 WBCS 기반 문자열 조작함수를 사용해야 한다.
            
    - WBCS 기반 문자열 조작함수 ? ( 보기 )
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2029.png)
        
        외우지 말고 핵심은
        
        전달되는 인자가 **wchar_t* 형태** 여야 한다는 것이다. 
        
    - 문제 3
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2030.png)
        
        - 호출 결과
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2031.png)
            
    - 문제 4
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2032.png)
        
        - 위의 함수를 호출할 때 발생하는 일  ( 3가지 설명 )
            - Windows2000 이상 운영체제는 유니코드를 지원한다.
            
            지원할 뿐만 아니라, **내부적으로 모든 문자열을 유니코드 기반으로 처리**한다.
            
            - 위 함수는 Hello World의 경우, **아스키 코드에 존재하는 문자들**로만
            
            구성되어 있으므로, **문자당 1 바이트로 표현**된다.
            
            printf 는 SBCS 기반 문자열 처리함수이지만, Windows 2000 이상 운영체제는
            
            전달되는 **문자열을 내부적으로 2바이트 유니코드 형식으로 변환**한다.
            
            왜냐하면 Windows2000 이상의 운영체제는 모든 문자열을
            
            유니코드 기반으로 처리하기 때문이다.
            
            - 이는 프로그램 성능에 다소 영향을 미치는 요소가 될 수 있다.
            
            되도록 유니코드 기반으로 프로그램을 작성하는 것이 좋다. 
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2033.png)
            
    - 유니코드 기반 한글을 출력하는 방법
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2034.png)
        
    - 문제 5
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2035.png)
        
        - 결과
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2036.png)
            
    - 문제 6
        
        ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2037.png)
        
        - 결과
            
            컴파일 에러
            
            fputws는 유니코드 기반으로 문자열을 처리하는 함수인데
            
            정작 인자로 전달되는 녀석은
            
            유니코드 기반이 아니라는 점이다.
            
        - 부분 해결책 + 문제가 되는 이유
            
            그러면 
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2038.png)
            
            main함수의 전달 인자를 이렇게 바꾸면 될까 ?
            
            컴파일은 되지만, 전혀 엉뚱한 결과를 출력하게 된다.
            
            **main 이라는 이름의 함수는 프로그램 실행 시,** 
            
            **전달되는 문자열을 MBCS 기반으로 구성하기 때문이다.**
            
        - 해결책
            
            ![Untitled](1%2021%205a4a501abe1b406d85b485ac0d6d2a41/Untitled%2039.png)
            
            wmain으로 구성한다.
            
            wmain은 프로그램 실행 시 전달되는 문자열을
            
            유니코드 기반으로 구성한다는 의미이다.