// 객체를 구성하는 데이터의 초기화 순서
// 1. 기본 클래스는 파생 클래스보다 먼저 초기화 된다.

// 2. 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화 된다.
// 초기화 리스트, 코드에 적은 순서는 다르더라도
// 선언된 순서대로 무조건 초기화 된다.
// 되도록, 선언한 순서대로 초기화 하자

// 3. 비정지역적 객체의 초기화 순서는
// 개별 번역 단위에서 정해진다.

// 정적 객체 static object
// 자신이 생성된 시점부터, 프로그램이 끝날 때까지
// 살아있는 객체 

// 따라서, 스택 및 힙 기반 객체는 정적 객체가 될 수 없다.
// 1) 전역 객체
// 2) 네임 스페이스 유효범위에서 정의된 객체
// 3) 클래스 안에서 static 으로 선언된 객체
// 4) 함수 안에서 static 으로 선언된 객체
// 5) 파일 유효 범위에서 static 으로 정의된 객체

// 지역 정적 객체 : 함수 안에 있는 정적 객체
// 그외 : 비지역 정적 객체 

// 총 5개의 정적 객체는, 프로그램이 끝날 때
// 자동으로 소멸된다.
// 즉, main() 함수의 실행이 끝날 때까지
// 정적 객체의 소멸자가 호출된다는 것이다. 

// 번역 단위(transloation unit) 은 컴파일을 통해
// 하나의 obj file 을 만드는 바탕이 되는 소스 코드를 말한다.
// 여기서 번역이란, 소스의 언어를 기계어로 옮긴다는 의미이다
// 기본적으로 소스 파일 하나가 되는데, 그 파일이 #include 하는
// 파일들 까지 합쳐서, 하나의 번역 단위가 된다.

// 별도로, 컴파일된 소스 파일이 2개 이상 있고
// 각 소스 파일에 비지역 정적 객체가 한개이상 들어있는 경우 
// 한쪽 번역 단위에 있는, 비정적 객체의 초기화가 진행되면서
// 다른쪽 번역 단위에 있는 비지역 정적 객체가 사용되는데
// 불행히도, 이 객체가 초기화되어 있지 않을지도 모른다는 점이다.
// 별개의 번역 단위에서 정의된 비지역 정적 객체들의 초기화 순서는
// 정해져 있지 않기 때문이다.

// 아래 객체는 전역 유효범위 혹은 name space 유효범위 안에 있다고 해보자
class FileSystem
{
    public :
        std::size_t numDisks() const ;
} 

extern FileSystem stf; // 사용자가 쓰게될 객체 

class Directory
{
    public :
        Directory(params);
};

Directory::Directory(params)
{
    // tfs 객체를 여기서 사용한다. 
    std::sze_t disks = tfs.numDisks();
}

// 임시파일을 담는 디렉토리
Directory tempDir(params)
;

// tf가 tempDir보다 먼저 초기화 되지 않으면
// tempDir의 생성자는 tf가 초기화 되지도 않았는데
// tfs를 사용하려 할 것이다.

// 그런데, tfs, tempDir은 제작자도 다르고
// 만들어진 시기도 다르고
// 소스파일도 다르다.

// 즉, 이들은 다른 번역 단위에서 정의된 비지역 정적 객체이다.
// 이를 해결하기 위해
// 비지역 정적 객체를 하나씩 맡는 함수를 준비하고
// 그 함수에서는 이들에 대한 참조자를 반환하게 만드는 것이다.

// 사용자 쪽에서는 비지역 정적 객체를 직접 참조하는
// 과거의 폐단을 버리고, 이제는 함수 호출로 대신한다.
// 이를 통해, 비지역 정적 객체가, 지역 정적 객체로 바뀐 것이다
// 이것이 바로 singleton pattern이다.

// 지역 정적 객체는 함수호출 중에 그 객체의 정의에 최초로 닿았을 때
// 초기화 되도록 만들어져 있다.
// 따라서, 비지역 정적 객체를 직접 접근하지 않고
// 지역 정적 객체에 대한 참조자를 반환하는 쪽으로 바꾸었다면
// 우리가 얻어낸 참조자는 반드시 초기화된 객체를 참조하도록
// 맞추어 주어야 한다.
class FileSystem{...};

FileSystem& tfs()
{
    static FileSystem fs;
    return fs;
}

class Directory {...};

Directory::Directory(params)
{
    ...
    std::size_t disks = tfs().numDisks();
}

Directory& tempDir()
{
    static Directory td;
    return td;
}


// 정리 ---  
// 여러 번역 단위에 있는 비지역 정적 객체들의 
// 초기화 순서 문제는 피해서 설계해야 한다
// 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다. 