
/*
항목 7. 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로  ----
*/

class TimeKeeper
{
    public :
        TimeKeeper();
        ~TimeKeeper(); // 비가상 소멸자
}

class AtomicClock : public TimeKeeper{...};

TimeKeeper* ptk = new AtomicClock;
delete ptk;

// 문제점
// 1. new 로 동적할당한 객체가, 파생 클래스(AtomicClock) 이리는 점
// 2. 이 포인터가 가리키는 객체가 삭제될 때는, 기본 클래스 포인터 (TimeKeeper) 를 통해 삭제된다는 점
// 3. TimeKeeper 내 소멸자가, 비가상 소멸자.라는 점 

// 기본 클래스 포인터를 통해, 파생 클래스 객체가 삭제될 때
// 그 기본 클래스에 비가상 소멸자가 들어있으면, 프로그램 동작은 미정의 사항
// 보통, 그 객체의 파생 클래스 부분이 소멸되지 않음

// 즉, AtomicClock 는 사라지지도 않고, 소멸자가 실행되지도 않는다. //

// 해결책 : 가상 소멸자 
class TimeKeeper
{
    public :
        TimeKeeper();
        virtual ~TimeKeeper(); // 가상 소멸자
}

// 가상 소멸자를 가지고 있지 않은 클래스를 만나면
// '아 저 클래스는, 기본 클래스로 쓰일 의지를 상실한 것이구나' 라고 생각하면 된다.
// 반대로, 
// 기본 클래스로 의도하지 안흔 클래스에 가상 소멸자를 선언하는 것도 좋지 않다. 

class Point 
{
    public :
        Point(int xCoord, int yCoord);
        ~Point();
    private :
    int x,y;
}

// 가상 함수 테이블 ?
// 가상함수를 C++ 에서 구현하려면, 클래스에 별도의 자료구조가 하나 들어가야 한다.
// 이 자료구조를 프로그램 실행 중에 주어진 객체에 대해 , 어떤 가상함수를 호출해야 하는지를 결정하는데 쓰이는 정보이다
// 실제로는 포인터의 형태를 취하는 것이 대부분이고, 대게 vptr 로 불린다 == 가상 함수 테이블 포인터
// 가상 함수의 주소, 즉, 포인터들의 배열을 가리키고 있고
// 가상 함수 테이블 포인터의 배열 vtbl(가상함수 테이블) 이라고 불린다.

// 가상함수를 하나라도 가지고 있는 클래스는 반드시 그와 관련된 vtbl (가상함수 테이블)을 지니고 있다.
// 어떤 객체에 대해 어떤 가상 함수가 호출되려고 하면
// 호출되는 실제 함수는, 그 객체의 vptr이 가리키는 vtbl에 따라 결정된다.
// vtbl 에 있는 함수 포인터들 중 적절한 것이 연결되는 것이다

// 중요한 것은, Point 클래스에 가상함수가 들어가게 되면
// Point 타입 객체의 크기가 커진다는 것이다
// 즉, int x,y == int 2개 + vptr (포인터 크기)
// ex) 32bit 환경 ==> 4byte + 4byte + 4byte(32bit = 포인터 크기) == 96bit
// ex) 64bit 환경 ==> 4byte + 4byte + 8byte(64bit = 포인터 크기) == 128bit 

// 즉, 핵심은, 소멸자를 전부 virtual 로 선언하는 일은 virtual로 절대 선언하지 않는 것만큼이나 편찮은 마인드.라는 것이다 