// 항목 7 
// 다형성을 가진 클래스에서는 
// 소멸자를 반드시 가상 소멸자로 선언하자

// 시간 기록 객체
class TimeKeeper
{
    public :
        TimeKeeper();
        ~TimeKeeper();
};

class AtomicClock : public TimeKeeper{...};

// 시간 정보에 접근은 하고 싶지만
// 시간 계산이 어떻게 되는지에 대해서는
// 신경 쓰고 싶지 않는다.

// 어떤 시간 기록 객체에 대한 포인터를
// 손에 넣는 용도로 팩토리 함수 
// : 새로 생성된 파생 클래스 객체에 대한
// 기본 클래스 포인터를 반환하는 함수
// 를 만들자

// TimeKeeper 에서 파생된 클래스를 통해
// 동적으로 할당된 객체의 포인터를 반환
TimeKeeper* getTimeKeeper();

// getTimeKeeper() 함수에서 반환되는 객체는
// 힙에 있게 된다.
// 결국 메모리 및 기타 자원의 누출을 막기 위해
// 해당 객체를 적절하게 delete 해야 한다
TimeKeeper* ptk = getTimeKeeper();
delete ptk;

// 여기서 주목할 점은 3가지 이다.
// 1. getTimeKeeper 함수가 반환하는 포인터가
// 파생 클래스 객체에 대한 포인터라는 점

// 2. 이 포인터가 가리키는 객체가 삭제될 때는
// 기본 클래스 포인터를 통해 삭제 된다는 점

// 3. 기본 클래스에 들어있는 소멸자가
// 비가상 소멸자라는 점

// C++ 규정에 따르면
// 기본 클래스 포인터를 통해 파생 클래스 객체가
// 삭제될 때 
// 그 기본 클래스에 비가상 소멸자가 들어있으면
// 프로그램 동작은 미정의 사항.
// 대게 그 객체의 파생 클래스 부분이
// 소멸되지 않게 된다.

// 이를 해결하기 위해 
// 가상 소멸자를 세팅하다

// 이제는 파생 클래스 객체를 기본 클래스
// 포인터로 삭제할 때,
// 우리가 원하는 쪽으로 동작하게 될 것이다 
// 기본 클래스의 소멸자 앞에 virtual 하나만 붙여주면
// 객체 전부가 소멸된다.

// 가상 소멸자를 가지고 있지 않은 클래스를 만나면
// 저 클래스는 기본 클래스로 쓰일 의지를 상실한 것이구나
// 라고 생각하면 된다.

// 반대로,
// 기본 클래스로 의도하지 않은 클래스에 대해
// 소멸자를 가상으로 선언하는 것은
// 좋지 않은 정신 자세이다.
class Point 
{
    public :
        Point(int xCoord, int yCoord);
        ~Point();
    private :
        int x,y;
}

// int가 32비트를 차지한다고 가정하면
// 이 Point 객체는 64비트 레지스터에 딱 맞게 들어갈 수 있다
// 즉, 64 비트의 크기의 자료로 넘어갈 것이다.
// 그런데, Point 클래스의 소멸자가 가상소멸자로 만들어지면
// 사정이 변하기 시작한다.

// 가상 함수를 C++ 에서 구현하려면
// 별도의 자료구조가 하나 들어가아 한다.

// 이 자료구조는 프로그램 실행 중에
// 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지를
// 결정하는데 쓰이는 정보인데,

// 실제로는 포인터의 형태를 취한다.
// 가상 함수 테이블 포인터 
// vtpr, virtual talbe pointer 라고도 부른다.

// vptr은 가상 함수의 주소
// 즉, 포인터들으 배열을 가리키고 있고
// 가상 함수 테이블 포인터의 배열은
// vtbl 이라고도 부른다.

// 가상 함수를 하나라도 갖고 있는 클래스는
// 반드시 그와 관련된 vtbl을 가지고 있다
// 어떤 객체에 대해 어떤 가상 함수가 호출되려고 하면
// 호출되는 실제 함수는 그 객체의
// vptr 이 가리키는 vtbl 에 따라
// 결정된다.

// 즉, vtbl 에 있는 함수 포인터들 중
// 적절한 것이 연결된다는 것이다. 

// 중요한 것은, point 클래스에 가상 함수가 들어가게 되면
// Point 타입 객체의 크기가 커진다는 것이다 

// 64비트 환경에서는 64 bit 가 추가된다
// 64 비트 시스템에서는 포인터의 크기가 64 비트이기 때문이다.  
// 즉, 가상 함수 테이블 포인터가 하나 추가됐을 뿐인데
// 크기가 매우 커진다는 것이다.
