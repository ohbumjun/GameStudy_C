/*
항목 6. 컴파일러에서 자동으로 제공하는 기능을 허용하지 않기  ------------------------
ex) 복사 막아버리기 
*/

/*
컴파일러가 만들어낸 함수가 필요 없으면
확실히 이들의 사용을 금해 버리자.

복사 생성자, 기본 생성자. 소멸자.
복사 대입 연산자는, 
우리가 선언하지 않고, 외부에서
이들을 호출하려고 한다면
컴파일러가 우리 대신에 선언해버린다.

만약 복사가 절대 안되게 하고 싶다면 ?

자. 컴파일러가 생성하는 함수는
모두 공개되는, public 함수이다.

따라서, 쓰고 싶지 않은 함수는
private으로 세팅하면 된다.

하지만, 여전히 해당 클래스의 멤버함수
및 프렌드 함수가 호출할 수 있다.

이를 위해, 
아예 정의를 안해버리면 안될까 ?
*/


// 방법
// 1) 대응되는 멤버 함수를 private 으로 선언하고
// 2) 구현은 하지 않은 채로 둬라 

// 1. 링커 시점 에러로 잡아버리기 
class HomeForSale
{
public :
    ...
private :
    // 매개변수는 필수가 아니다. 읽기 좋으라고 있는 것일 뿐
    // 아래와 깉이 "선언"만 해준다;
    // 사용자가 HomeForSale 객체의 복사를 시도하려고 하면
    // 컴파일러가 강한 백태클을 걸 것이다 
    HomeForSale(const HomeForSale& ); 
    HomeForSale* operator = (const HomeForSale&);
}

// 2. 링크 시점 에러를 컴파일 시점 에러로 옮겨버리기 --> 에러 탐지를 나중으로 미루는 것보다 미리하게 되는 것

// 복사 생성자와, 복사 대입 연산자를 private 선언
// HomeForSale 자체에 넣지 말고, 별도의 기본 클래스에 넣고, 이로부터 HomeForSale을 파생시키기
// 별도의 기본 클래스는 복사 방지만 맡는다. 라는 특별한 의미를 부여한다. 

class Uncopyable
{
    protected : // 파생된 객체에 대하여
        Uncopyable(){} // 생성과 소멸을 허용
        ~Uncopyable(){}
    private :
        Uncopyable(const Uncopyable&); // 복사는 방지
        Uncopyable& operator =(const Uncopyable&);
}

// 복사 생성자도, 복사 대입 연산자도 이제는 선언되지 않는다 
// 기본 클래스 Uncopyable에서 복사,대입 연산자를 "선언" only + "private" 세팅 
class HomeForSale : private  Uncopyable{}

// HomeForSale 객체의 복사를 외부함수(멤버함수 or 프렌드 함수까지도) 에서 시도하려고 할때
// 컴파일러는 HomeForSale 클래스만의 복사 생성자와 복사 대입 연산자를 만드려고 할 것이다
// 컴파일러가 생성한 복사 함수는, 기본 클래스의 대응버전을 호출하게 되어 있다.
// 그런데 이런 호출은 통하지 않는다. 복사 함수들이 기본 클래스에서 공개되어 있지 않기 때문이다 

