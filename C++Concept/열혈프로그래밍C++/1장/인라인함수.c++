// Q. 취지 : 실행속도가 빠른 매크로 함수의 이점을 활용 + 정의가 어려운 매크로 함수의 단점은 극복

// Q. 매크로함수에는 있지만 인라인 함수에는 없는 장점 + 극복 방법
// 매크로함수는 자료형에 의존적이지 않지만, 인라인 함수는 자료에 의존적이다
// templat 과 같이 활용하면 이러한 단점을 극복할 수 있다. 

// Q. obj, exe 파일 ? (프로그램이 만들어지는 과정)
// 컴퓨터 프로그램을 만든다는 이야기는, 실행파일에 해당하는 .exe 파일을 만든다는 의미이다
// 1) C++ 소스파일을 짠다 -> 2) 컴파이러를 통해 기계어 파일로 변환한다 : .obj 파일
// -> 3) 링커를 통해 목적파일 .obj 파일들을 연결시켜 .exe 파일을 만들어낸다. 

// Q. 컴파일러와의 관계 ---
// 매크로를 이용한 함수의 인라인화는, 전처리기에 의해 처리되지만
// 키워드 inline을 이요한 함수의 인라인 화는 컴파일러에 의해 처리가 된다.

// Q. 장점과 단점
// 실행 속도는 줄이지만, 실행 코드가 늘어나게 되어, 컴파일 시간이 늘어나고, 실행 파일의 크기가 커진다 
#include<iostream>

template<typename T>
inline int SQUARE(T x) // 이 부분이 컴파일 단계에서, 아래 SQUARE 함수에서 몸통부분으로 변환되어 들어간다.
                        // 즉, 코드의 길이가, 함수 몸통 부분 만큼 늘어나는 것이다. 실행 파일의 크기가 늘어난다. 
{
    return x*x;
};

int main()
{
    std::cout << SQUARE(5) << std::endl; 
    std::cout << SQUARE(6) << std::endl;
    std::cout << SQUARE(7) << std::endl;
    return 0;
}

// Q. 단점에 대처하는 방법
// 컴파일러는 필요에 따라 inline 함수들을 직접 선언하여, 컴파일 하기도 하고, 
// inline 함수로 선언된 부분을 일반 함수로 처리하기도 한다. 