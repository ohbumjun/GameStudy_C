// Q. 아래 코드의 문제점 ---
// const 선언을 통해, 변수 num을 상수화 했는데
// 참조자 ref를 통해서 값을 변경한다 ? 이는 num의 상수화가 의미가 없어지는 것이다
// 이를 컴파일러는 방지해준다.
const int num = 20;
int &ref = num;
ref += 10;


// 아래 코드가 동작하게 된다.
const int& ref = num;


// Q. 아래 코드가 동작하는 이유 ? 50 의 명칭 ?
const int &ref = 50;

// 원래 참조자는 선언과 동시에 초기화 되어야 하고 ,
// 변수만 참조 가능하다. 그런데 위는 변수가 아닌 상수를 참조하고 있다. 

// 50 등, 프로그램 상의 표현되는 숫자를 가리켜 "리터럴(literal) 혹은 리터럴 상수(literal constant)"라 한다.
// 정의 : 임시적으로 존재하는 값이다. 다음 행으로 넘어가면, 존재하지 않는 상수다. 

// const int& ref = 50 이 가능하려면
// 50이 메모리 공간에 계속 남아있을 때에나 성립이 가능한 문장이다.
// 이를 성립하게 하기 위해서, const 참조자를 이용해서, 상수를 참조할 때
// "임시 변수"라는 것을 만들고, 그 장소에 상수 50을 저장하고, 참조자가 이를 참조하게 한다.
// 즉, 임시로 생성한 변수를 상수화 하여, 이를 참조자가 참조하게 하는 구조이다.
// 결과적으로 "상수화된 변수"를 참조하는 구조가 된다. 

// Q. 위와 같은 코드 구조를 만들어낸 이유

int Adder(const int &num1, const int &num2)
{
    return num1 + num2;
};

std::cout << Adder(3,4);
// 함수에 인자의 전달을 목적으로 변수를 추가적으로 선언하는 것은 불편하다
// 임시변수의 생성을 통한 "const 참조자의 상수참조"를 허용함으로써 위 코드를 가능하게 한다. 