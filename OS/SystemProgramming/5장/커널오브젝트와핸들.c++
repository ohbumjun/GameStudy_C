/*
프로세스 A 생성 ?
- 프로세스 A 커널 오브젝트 생성
- 프로세스 A 핸들 테이블  생성

프로세스 A 를 생성하면, 커널 오브젝트를 구분해주는 고유한 번호 , 핸들이 생성되고
해당 핸들을 통해 프로세스 A 커널 오브젝트에 접근할 수 있다.

A 핸들을 3으로 등록
A 핸들 테이블에는 3이 등록되고, 해당 핸들에 대한 대상은, 자기 자신의 커널 오브젝트를 가리킨다.
즉, 핸들값이 직접적으로 커널 오브젝트에 mapping되는 것이 아니라
핸들 테이블에 가서 보니까 , 핸들 3은, 그 대상이 커널 오브젝트 

간접적인 연결 형태를 취한다는 것이다. 

---------
UC : Usage Count
- 프로세스 A를 현재 몇명이 사용하는가
- 생성 하는 순간 UC는 2가 된다.
?? 왜 1이 아니라 2가 되는 것일까
프로세스 A가 실행될 때는, 사실 ex) 바탕화면 더블클릭
등 다른 부모 프로세스에 의해 실행되기 때문에
프로세스 A도 부모 프로세스이지만, 동시에
다른 부모 프로세스로부터 실행되기 때문이다.  

프로세스 A를 통해 프로세스 B를 만든다고 해보자. 

프로세스 B도 핸들 값을 4으로 두고
이 정보는 프로세스 B의 핸들 테이블에 저장한다.

이 경우 B 프로세스의 UC는 1이 아니라 2가 된다.

왜 ?
- 1) 먼저, 프로세스 A를 통해 프로세스 B를 만들면
프로세스 B의 커널 오브젝트에 접근할 수 있는 프로세스 B의 핸들값이 프로세스 A에게 반환되어, 
프로세스 A 핸들 테이블에 저장된다.
- 2) 다른 말로 하면, 같은 핸들값을 사용할 수 없다는 의미이다.
- 그러면 프로세스 A 핸들 테이블에서 3 핸들값은, 프로세스 A 커널 오브젝트 ,
    예를 들어, 4라는 핸들값은 프로세스 B 커널 오브젝트를 가리킨다는 것이다
- 단, 프로세스 B 핸드 테이블에는 핸들 값 3이 프로세스 B 커널 오브젝트.를 가리키게 할 수 있다. 
- 즉, 핸들값은, 프로세스에 종속적이다. 핸들 테이블도 프로세스에 종속적이다
서로 다른 테이블에 저장된 같은 핸들값은, 전혀 다른 대상을 가리키게 된다는 것이다. 
- 3) 그러면 프로세스 A, 프로세스 B 각각 테이블에 프로세스 B 커널오브젝트에 대한 핸들값이 저장된다.
따라서 UC가 1 이 아니라, 2가 되는 것이다.

---

한편, 프로세스 B에서 파일을 하나 생성한다.
- 파일에 대한 핸들값이 프로세스 B 테이블에 저장되고
- 그 대상은 파일 커널 오브젝트를 가리킨다.
이 경우는 파일 커널 오브젝트의 UC가 1이 된다.
왜냐하면 모든 곳을 찾아봐도, 해당 파일 커널 오브젝트에 접근할 수 있는 곳은
프로세스 B 밖에 없기 때문이다.

즉, 모든 리소스가 UC 가 2가 되는 것은 아니라는 의미이다

---
UC 는 왜 두는 것일까 ? 
프로세스 B가 소멸되어도, 
프로세스 A는 여전히 프로세스 B 커널 오브젝트에 관심있을 수 있다.
따라서 , Shaderptr 형태로 count를 감소시켜가면서
0 이 될때 사라지게 하는 것이다.

즉, 운영체제 영역에서, 
커널 오브젝트가 존재한다는 것은
얘네들이 실제 종료시키는 것은 운영체제

언제 종료 ?
얘한테 관심있던 애들에 대한 개수를 반영하는
UC count를 감소시켜가면서
ex) 프로세스가 소멸, or 단순히 다 이제 관심없어요 ! 라고 세팅 
0 이 되면 소멸시키겠다는 의미이다. 

--- 
프로세스 B가 소멸되면, 파일 커널 오브젝트에 대한 count 개수가 0이 된다.
파일 커널 오브젝트가 사라진다고 해서
파일이 사라지는 것은 아니다
파일은 물리적으로 존재하지


*/