#include<iostream>

/*
상속 : 클래스는 부모와 자식의 관계를
형성할 수 있다. 

상속관계에서 생성자와 소멸자의 호출 순서
생성자 : 부모 -> 자식
소멸자 : 자식 -> 부모

---- 
protected : 클래스의 외부에서는 접근이 불가능하고
클래스의 내부 혹은 자식 클래스 내부에서는
접근이 가능하다

----
상속을 사용하는 이유
1) 재사용성
2) 다형성

재사용성 :
보통 상속을 사용하는 이유는, 클래스의 재사용성도
하나의 이유가 된다. 
부모클래스에 공통으로 가져아할 멤버변수를 선언하고
공통으로 가져야할 기능을 멤버함수를 만들어준 후에

개별적인 내용들만, 자식클래스에 따로
조금씩 만들어서 하나의 객체를 만들 때 사용한다.

다형성 :
상속관계에 있는 클래스들은 서로 형변환이 가능하다.
다양한 부모와 자식 타입으로의 형변환을
지원해주기 때문에, 같은 부모를 상속받고 있는
자식 클래스는 해당 부모타입으로 모든 자식클래스 타입의
변수들을 부모타입으로 관리가
가능해지게 되는 것이다.

업캐스팅   : 자식 -> 부모
다운캐스팅 : 부모 -> 자식

가상함수 : 
함수 앞에 virtual을 붙여서
가상함수로 만들어줄 수 있다.

가상함수를 가지고 있는 클래스를 이용해서
객체를 생성하면, 가상함수 테이블의 주소를
가지고 있는 포인터변수를 내부적으로 가지게 된다.

가상함수 테이블은 해당 클래스가 가지고 있는
가상함수의 함수주소를 저장하고 있는
배열이라고 볼 수 있다.
클래스를 이용해서 객체를 생성하면 ,
내부에 __vfptr 포인터 변수가 만들어지고
이 변수에 가상함수테이블 배열의
메모리 시작주소가 들어가게 된다. 

가상함수는 자식클래스에서
해당함수를 재정의할 수 있다.
이를 함수 오버라이딩이라고 한다.

함수를 재정의할 때는 반환타입, 인자가 모두
동일해야 한다.

함수 이름도 당연히 동일해야 한다.
함수 재정의이기 때문에 말 그대로, 해당 함수를
자식클래스에 다시 만들어서, 자식클래스의 함수가
호출될 수 있도록 만들어주는 기능인 것이다.

소멸자는 모든 클래스가 공통되게 이름만 다를 뿐 ,
소멸자이므로, 부모 클래스의 소멸자에
virtual을 붙여주면, 자식클래스는 자동으로
재정의된 소멸자, 즉 자기 자신의 소멸자를
호출하게 되는 것이다.

일반 멤버함수에 virtual을 붙여서 가상함수로 
만들어주면, 자식클래스의 재정의를 해도 되고
안해도 된다.

만약 CChild클래스는 재정의가 되어 있고
CChild1 클래스는 재정의가 안되었을 경우,

가상함수 테이블에 저장되는 함수의 주소는
CChild 클래스를 이용해서 생성한 객체는
CChild클래스에 재정의한 함수의 주소가 들어가게 되고

CChild1클래스를 이용해서 생성한 객체는
재정의가 안되어 있으므로
CParent 클래스에 정의된 함수의
주소가 들어가게 되는 것이다.

그래서 가상함수를 호출을 하게 되면,
먼저 가상함수인지를 판단하고,
가상함수라면, 가상함수 테이블에서
실제 함수의 주소를 찾아온 후에
해당 함수의 주소를 이용하여
함수호출을 진행하게 되므로,

CChild클래스를 이용해서 생성한 객체는
가상함수테이블에 CChild클래스에 재정의된 함수의
주소가 들어가 있으므로, 재정의된 함수를 호출해주고

CChild1 클래스를 이용해서 생성한 객체는
가상함수 테이블에서 CParent 클래스에 선언된
함수의 주소가 들어가 있으므로
해당함수를 호출하게 되는 것이다.


*/

using namespace std;

class CParent
{
public :
	CParent()
	{
		cout << "CParent 생성자" << endl;
	}
	virtual ~CParent()
	{
		cout << "CParent 소멸자" << endl;
	}
};